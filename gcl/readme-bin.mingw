Hi there!

You are installing GNU Common Lisp for Windows, 2.5.3
This compiler depends on Mingw32 GCC (see below).

DO NOT INSTALL INTO A DIRECTORY WITH SPACES IN THE NAME.

 (CONTRACTED DOS NAMES ARE FINE EG: C:\PROGRA~1\GCL)

This build contains primitive C library bindings for the 
cross-platform JAPI GUI library.  To get at them execute

    (in-package :JAPI-PRIMITIVES)

To learn how to use this library, see the code in the
section marked "JAPI EXAMPLE" included at the bottom
of this text.  That code shows basic stuff such as how to
set up menus, draw graphics and text and simple mouse event
handling.


MINGW32 GCC:
===========

The MinGW compiler is provided under the terms of the files:

 "COPYING" and "COPYING.LIB"

which are located in the mingw sub-directory.  The source 
code and updated binary packages can be obtained via the 
official MinGW web site:

http://sourceforge.net/projects/mingw/

It is recommended that you use the compiler provided
when working with this GCL package to ensure C compiler
compatibility.  

Clean and rebuild pre-existing projects whenever you
upgrade the GCL binary package for this reason.


RELEASE NOTES FOR 2.5.1:
========================
The GNU Common Lisp (GCL) development team is pleased to release
Version 2.5.1, the first major release since the untimely death of the
former maintainer Dr William Schelter over a year ago.  This release
is dedicated to his memory.  The project is now hosted on
http://savannah.gnu.org/projects/gcl/ and is maintained and developed
by a team of thirteen programmers.  Our home page lives at
http://www.gnu.org/software/gcl/.

This release stabilizes the CLtL1 compliant build of GCL on most major
Unices including 11 Debian Linux 64 and 32 bit architectures and modern
versions of Microsoft Windows (TM).  A rapidly progressing, partially ANSI
compliant version is also available on the Linux platforms.

GCL plays a substantial role in development of the Maxima computer
algebra system (http://maxima.sourceforge.net/), ACL2, a computational
logic system (http://www.cs.utexas.edu/users/moore/acl2/), and the
forthcoming public release of the Axiom computer algebra system..  The
compiler is a descendant of the famous KCL and AKCL Common Lisp
compilers and is licensed under version two of the GNU Library General
Public License.

As with any Lisp system GCL is a lot of fun to work with.  We welcome all
comments and feedback.   Developers are particularly welcome too.  You will
find that the project offers a wide variety of challenges on various
platforms to anyone with an interest in compilers, low level C programming
or Common Lisp.

-----

Features:

    * Compiles itself, maxima, and acl2, passing all tests, on 11
        Debian GNU/Linux platforms (i386, sparc, powerpc, s390, ia64, alpha,
        mips, mipsel, hppa, arm, and m68k), Sparc Solaris, and recent Windows
        systems.

    * Compilation to native object code.  Lisp disassembly shows intermediate 
	C source and native assembler. 
   
    * Native code relocation on all supported platforms except alpha, mips, 
	mipsel, ia64, and hppa. 

    * Can save its running memory image to a file on all systems where native object 
	code relocation is supported, thus producing standalone executables.

    * Compiles Lisp function calls to C function calls with inlined
	arguments, when function proclamation/declamations are made.

    * Quite fast, particularly if one pre-allocates memory to be commensurate
	 with that typically available on modern computer systems. (see below)

    * A foreign function interface as flexible in principle as the C interface.

    * Socket support via streams

    * Support for numbers of arbitrary precision via the GNU
	Multiprecision Library.  If you build GCL on your own system,
	multiprecision numerical support will make use of ISA extension
	instructions available on your system for maximum large number
	performance.

    * An exact garbage collector with no (known) leaks.

    * An ANSI mode on Unix systems which passes approximately 97% of
	the ANSI compliance tests currently developed for the project.
	On Debian GNU/Linux systems, this mode can be selected by setting the
	GCL_ANSI environment variable to any non-empty string.  See
	/usr/share/doc/gcl/test_results on Debian GNU/Linux systems.

    * An MPI extension for cluster computing support.  See the website for details. 

    * A long history of leveraging GCC compiler technology for use in
	production lisp applications.

-----

GCL is one of the oldest Lisp systems still in use, and as such has
served as the basis for large lisp applications when computers were
much more limited than they are today, particularly in terms of
available memory.  Considerable effort was therefore made in the past
to keep the memory image as small as possible.  As of the present
time, the GCL team has not tuned the default memory allocation scheme
to be more in line with modern systems.  One can therefore often get
significant performance increases by preallocating memory, as in for
example

(progn
(si::allocate 'cons 10000 t)
(si::allocate 'fixnum 200 t)
(si::allocate 'symbol 100 t)
(si::allocate-relocatable-pages 2000 t)
(si::allocate 'cfun 1000 t))

Optimal values will no doubt vary by application and machine.  One
user/developer reports effects of the following magnitude when
using preallocation:

########

Take a look on some funny numbers below.  This is time and RAM
required to compute ratsimp((x+y+z)^300)$ on Linux AthlonXP 2400+.
For GCL run time is in the form T - G = N, where T is the total
time as shown by showtime:true; G is total GC tome and N
is run time without GC.

Lisp            Time            RAM      RAM    RAM
                 [sec]          before    max   after
              T  -  G  = N       [Mb]    [Mb]    [Mb]
=====================================================

CLISP       4.6                 5.5      29      16

CMUCL       1.6                 6.5      31      31

GCL class   5.9 - 5.2 = 0.7      8       24      24
GCL ansi    9.5 - 8.9 = 0.6     9.5      29      29

GCL class   1.0 - 0.4 = 0.6     24       31      31
GCL ansi    1.1 - 0.6 = 0.5     25       32      32

GCL class   0.7 - 0.1 = 0.6     48       55      55
GCL ansi    0.5 - 0.0 = 0.5     49       56      56

====================================================

########


TO DO:

	1) Full ANSI compliance
	2) Native optimized blas support
	3) Integrate MPI support
	4) GCL as a suported GCC front end.
	5) Performance/memory optimization


=================================================================================
JAPI EXAMPLE
============

;;;
;;; Japi is a cross-platform, easy to use (rough and ready) Java based GUI library
;;; Download a library and headers for your platform, and get the C examples
;;; and documentation from:
;;;
;;;     http://www.japi.de/
;;;
;;; This file shows how to use some of the available functions.  You may assume
;;; that the only functions tested so far in the binding are those which appear
;;; below, as this file doubles as the test program.  The binding is so simple
;;; however that so far no binding (APART FROM J_PRINT) has gone wrong of those
;;; tested so far! 
;;;
;;;
;;; HOW TO USE THIS FILE
;;;
;;; (compile-file "c:/cvs/gcl/japitest.lsp") (load "c:/cvs/gcl/japitest.o")
;;;
;;; Requires either "java" or "jre" in the path to work.
;;;

(in-package :japi-primitives)

;; Start up the Japi server (needs to find either "java" or "jre" in your path
(defmacro with-server ((app-name debug-level) . body)
  (multiple-value-bind (ds b)
		       (si::find-declarations body)
		       `(if (= 0 (j_start))
			    (format t (format nil "~S can't connect to the Japi GUI server." ,app-name))
			  (progn
			    (j_setdebug ,debug-level)
			    ,@ds
			    (unwind-protect
				(progn ,@b)
			      (j_quit))))))

;; Use a frame and clean up afterwards even if trouble ensues
(defmacro with-frame ((frame-var-name title) . body)
  (multiple-value-bind (ds b)
		       (si::find-declarations body)
		       `(let ((,frame-var-name (j_frame ,title)))
			  ,@ds
			  (unwind-protect
			      (progn ,@b)
			    (j_dispose ,frame-var-name)))))

;; Use a canvas and clean up afterwards even if trouble ensues
(defmacro with-canvas ((canvas-var-name frame-obj x-size y-size) . body)
  (multiple-value-bind (ds b)
		       (si::find-declarations body)
		       `(let ((,canvas-var-name (j_canvas ,frame-obj ,x-size ,y-size)))
			  ,@ds
			  (unwind-protect
			      (progn ,@b)
			    (j_dispose ,canvas-var-name)))))

;; Use a pulldown menu bar and clean up afterwards even if trouble ensues
(defmacro with-menu-bar ((bar-var-name frame-obj) . body)
  (multiple-value-bind (ds b)
		       (si::find-declarations body)
		       `(let ((,bar-var-name (j_menubar ,frame-obj)))
			  ,@ds
			  (unwind-protect
			      (progn ,@b)
			    (j_dispose ,bar-var-name)))))

;; Add a pulldown menu and clean up afterwards even if trouble ensues
(defmacro with-menu ((menu-var-name bar-obj title) . body)
  (multiple-value-bind (ds b)
		       (si::find-declarations body)
		       `(let ((,menu-var-name (j_menu ,bar-obj ,title)))
			  ,@ds
			  (unwind-protect
			      (progn ,@b)
			    (j_dispose ,menu-var-name)))))

;; Add a pulldown menu item and clean up afterwards even if trouble ensues
(defmacro with-menu-item ((item-var-name menu-obj title) . body)
  (multiple-value-bind (ds b)
		       (si::find-declarations body)
		       `(let ((,item-var-name (j_menuitem ,menu-obj ,title)))
			  ,@ds
			  (unwind-protect
			      (progn ,@b)
			    (j_dispose ,item-var-name)))))

;; Add a mouse listener and clean up afterwards even if trouble ensues
(defmacro with-mouse-listener ((var-name obj type) . body)
  (multiple-value-bind (ds b)
		       (si::find-declarations body)
		       `(let ((,var-name (j_mouselistener ,obj ,type)))
			  ,@ds
			  (unwind-protect
			      (progn ,@b)
			    (j_dispose ,var-name)))))

;; Run a five second frame in a Japi server
(with-server ("GCL Japi library test GUI 1" 0)
	     (with-frame (frame "Five Second Blank Test Frame") 
			 (j_show frame)
			 (j_sleep 5000)))

;; Get a pointer to an array of ints
(defCfun "static void* inta_ptr(object s)" 0 
  " return(s->fixa.fixa_self);")
(defentry inta-ptr (object) (int "inta_ptr"))

;; Draw function
(defun drawgraphics (drawable xmin ymin xmax ymax)
  (let* ((fntsize 10)
	 (tmpstrx (format nil "XMax = ~D" xmax))
	 (tmpstry (format nil "YMax = ~D" ymax))
	 (tmpstrwidx (j_getstringwidth drawable tmpstrx)))
    (j_setfontsize drawable fntsize)
    (j_setnamedcolor drawable J_RED)

    (j_drawline drawable xmin ymin        (- xmax 1)      (- ymax 1))
    (j_drawline drawable xmin (- ymax 1)  (- xmax 1)      ymin)
    (j_drawrect drawable xmin ymin        (- xmax xmin 1) (- ymax xmin 1))

    (j_setnamedcolor drawable J_BLACK)
    (j_drawline drawable xmin (- ymax 30) (- xmax 1)      (- ymax 30))
    (j_drawstring drawable (- (/ xmax 2) (/ tmpstrwidx 2)) (- ymax 40) tmpstrx)

    (j_drawline drawable (+ xmin 30) ymin (+ xmin 30) (- ymax 1))
    (j_drawstring drawable (+ xmin 50) 40 tmpstry)

    (j_setnamedcolor drawable J_MAGENTA)
    (loop for i from 1 to 10
	  do (j_drawoval drawable
			 (+ xmin (/ (- xmax xmin) 2)) 
			 (+ ymin (/ (- ymax ymin) 2))
			 (* (/ (- xmax xmin) 20) i)
			 (* (/ (- ymax ymin) 20) i)))

    (j_setnamedcolor drawable J_BLUE)
    (let ((y ymin)
	  (teststr "JAPI Test Text"))
      (loop for i from 5 to 21 do
	    (j_setfontsize drawable i)
	    (let ((x (- xmax (j_getstringwidth drawable teststr))))
	      (setf y (+ y (j_getfontheight drawable)))
	      (j_drawstring drawable x y teststr))))))

;; Run some more extensive tests
(with-server
 ("GCL Japi library test GUI 2" 0)
 (with-frame
  (frame "Draw")
  (j_show frame)
  (let ((alert (j_messagebox frame "Two second alert box" "label"))) 
    (j_sleep 2000)
    (j_dispose alert))
  (let ((result1 (j_alertbox frame "label1" "label2" "OK"))
	(result2 (j_choicebox2 frame "label1" "label2" "Yes" "No"))
	(result3 (j_choicebox3 frame "label1" "label2" "Yes" "No" "Cancel")))
    (format t "Requestor results were: ~D, ~D, ~D~%" result1 result2 result3))
  (j_setborderlayout frame)
  (with-menu-bar
   (menubar frame)
   (with-menu
    (file menubar "File")
    (with-menu-item
     (print file "Print")
     (with-menu-item
      (save file "Save BMP")
      (with-menu-item
       (quit file "Quit")
       (with-canvas  
	(canvas frame 400 600)
	(j_pack frame)
	(drawgraphics canvas 0 0 (j_getwidth canvas) (j_getheight canvas))
	(j_show frame)
	(do ((obj (j_nextaction) (j_nextaction)))
	    ((or (= obj frame) (= obj quit)) t)
	    (when (= obj canvas)
	      (j_setnamedcolorbg canvas J_WHITE)
	      (drawgraphics canvas 10 10
			    (- (j_getwidth canvas) 10)
			    (- (j_getheight canvas) 10)))
	    (when (= obj print)
	      (let ((printer (j_printer frame)))
		(when (> 0 printer)
		  (drawgraphics printer 40 40
				(- (j_getwidth printer) 80)
				(- (j_getheight printer) 80))
		  (j_print printer))))
	    (when (= obj save)
	      (let ((image (j_image 600 800)))
		(drawgraphics image 0 0 600 800)
		(when (= 0 (j_saveimage image "test.bmp" J_BMP))
		  (j_alertbox frame "Problems" "Can't save the image" "OK")))))))))))))
;; Try some mouse handling
(with-server
 ("GCL Japi library test GUI 3" 0)
 (with-frame
  (frame "Move and drag the mouse")
  (j_setsize frame 430 240)
  (j_setnamedcolorbg frame J_LIGHT_GRAY)
  (with-canvas
   (canvas1 frame 200 200)
   (with-canvas
    (canvas2 frame 200 200)
    (j_setpos canvas1 10 30)
    (j_setpos canvas2 220 30)
    (with-mouse-listener
     (pressed canvas1 J_PRESSED)
     (with-mouse-listener
      (dragged canvas1 J_DRAGGED)
      (with-mouse-listener
       (released canvas1 J_RELEASED)
       (with-mouse-listener
	(entered canvas2 J_ENTERERD)
	(with-mouse-listener
	 (moved canvas2 J_MOVED)
	 (with-mouse-listener
	  (exited canvas2 J_EXITED)
	  (j_show frame)
          ;; Allocate immovable storage for passing data back from C land.
	  ;; Uses the GCL only make-array keyword :static
	  (let* ((xa (make-array 1 :initial-element 0 :element-type 'fixnum :static t))
		 (ya (make-array 1 :initial-element 0 :element-type 'fixnum :static t))
		 (pxa (inta-ptr xa))
		 (pya (inta-ptr ya))
		 (x 0)
		 (y 0)
		 (get-mouse-xy (lambda (obj)
				 (progn (j_getmousepos obj pxa pya)
					(setf x (aref xa 0))
					(setf y (aref ya 0)))))
		 (startx 0)
		 (starty 0))
	    (do ((obj (j_nextaction) (j_nextaction)))
		((= obj frame) t)
		(when (= obj pressed)
		  (funcall get-mouse-xy pressed)
		  (setf startx x)
		  (setf starty y))
		(when (= obj dragged)
		  (funcall get-mouse-xy dragged)
		  (j_drawrect canvas1 startx starty (- x startx) (- y starty)))
		(when (= obj released)
		  (funcall get-mouse-xy released)
		  (j_drawrect canvas1 startx starty (- x startx) (- y starty)))
		(when (= obj entered)
		  (funcall get-mouse-xy entered)
		  (setf startx x)
		  (setf starty y))
		(when (= obj moved)
		  (funcall get-mouse-xy moved)
		  (j_drawline canvas2 startx starty x y))
		(setf startx x)
		(setf starty y)
		(when (= obj exited)
		  (funcall get-mouse-xy exited)
		  (j_drawline canvas2 startx starty x y))))))))))))))

