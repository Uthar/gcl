This is a list of bugs that have been found in gcl.  When you fix
a bug, add the notation (FIXED) after the bug number, but leave the
number in place so it isn't reused.

1 (FIXED). (subtypep s 'structure-object) isn't working properly when
  s is a structure class name or a structure class object.
  This is causing 95 ansi-test failures.

2. (sublis x y :test #'fn) is passing the arguments to fn in the
  wrong order.  The problem here is that the :key argument is being
  applied somewhat unusually, making the usual TEST macro not do
  quite the right thing.  ansi-tests: sublis.9 and sublis.10

3. (nsublis x y :test #'fn) is passing the arguments to fn in the
  wrong order. Similar to bug #2.  ansi-tests:  nsublis.10 and nsublis.11

4. (last x n) is incorrectly signaling an error when n is a positive
  bignum.  Instead, it should return x.   ansi-tests: last.11, last.12

5. The map* functions should signal a type error when given an improper
  list.  They do so, but the slots of the type error object don't
  satisfy the property that the value in the datum slot is not of
  the type in the expected-type slot.  ansi-tests: mapc.error.8,
  mapcar.error.8, mapcan.error.8, mapl.error.8, maplist.error.11,
  mapcon.error.8

6. Similar to #5, but the error is for GET-PROPERTIES.  ansi-tests:
   get-properties.error.[456]

7. (SETF (GETF form1 form2 form3) form4) is evaluating the subforms
  in the wrong order: form3 is being evaluated before (the subforms of)
  form1 and form2.  ansi-tests: setf-getf.order.2

8. Similar to #5, but the error is for GETF.  ansi-tests: getf.error.[45]

9. REMF is violating the requirement that the value of the place be
  read out after all the other subforms of the REMF form are computed
  (even the ones to the right of the place form; see section 5.1.3
  of CLtS).  ansi-tests:  remf.order.3

10. Similar to #5, but on ELT when the index is out of range.  Should
  return a type-error with datum == the index and type ==
  `(integer 0 (,(length sequence))) (or NIL if the sequence has length 0).
  ani-tests:  elt.1, elt.1b, elt.2, 

11. There's an internal type error somewhere in the code exercised by
  elt.10 -- the invalid type (integer 0 . 1) is being passed to TYPEP
  (and similarly for elt.14, elt-v.1, elt-v.10, elt-adj-array.1,
   elt-adj-array.10, elt-displaced-array.1, elt-fill-pointer.[3468],
   and elt,error.[45]).

12. Coerce can't coerce a vector of characters into a base-string.
  ansi-tests: fill.string.10

13. MAKE-SEQUENCE fails on type argument NULL,. (CLASS-OF NIL), or LIST.
   ansi-tests: make-sequence,9, make-sequence.49. make-sequence.57

14. The datum and expected type fields of the type errors thrown by
   MAKE-SEQUENCE, MAP  do not satisfy the constraint that the datum
   is not of type expected-type.  ansi-tests: make-sequence.error.1,
   make-sequence.error.2, make-sequence.error.14, make-sequence.error.16,
   map.error.1, map.error.1a, map.error.11.

15. MAP fails on type argument NULL, (OR (VECTOR 5) (VECTOR 10))
   ansi-tests: map-null.1, map.48

16. NREVERSE is broken on vectors of element type LISP:SIGNED-SHORT

    (let ((v (make-array '(7) :initial-contents '(1 1 0 1 1 1 0)
                  :element-type 'lisp:signed-short)))
      (nreverse v))
    ==> #(0 1 1 1 1 1 0)

   (ansi-tests: nreverse-vector.7, nreverse-vector.8)

17. The setf expander for SUBSEQ returns the wrong value (the entire
   vector is returned rather than the aubsequence being assigned.)
   ansi-tests: subseq.order.[34]

18. CONCATENATE fails on type argument of NULL, as does MERGE.
   ansi-tests:. concatenate.24, merge-null.1, merge.error.6

19, There are 140 symbols exported from the COMMON-LISP package that
   should not be external in that package.
   ansi-tests: no-extra-symbols-exported-from-common-lisp
    all-exported-cl-class-names-are-valid

20. 19 functions are missing: arithmetic-error-operands
  broadcast-stream-streams cell-error-name concatenated-stream-streams
  echo-stream-input-stream echo-stream-output-stream
  function-lambda-expression get-setf-expansion
  make-load-form-saving-slots pprint-indent pprint-newline
  pprint-tab print-not-readable-object simple-condition-format-control
  synonym-stream-symbol two-way-stream-input-stream
  two-way-stream-output-stream unbound-slot-instance
  compiler-macro-function readtable-case.

  ansi-tests: cl-function-symbols.1, dcf-funs and these tests:

   cell-error-name:
      symbol-value.error.5 symbol-function.error.5 makunbound.2
      eval.error.3 eval.error.4 cell-error-name.[123456]
      cell-error-name.error.[12]

   get-setf-expansion
      get-setf-expansion.error.[12] get-setf-expansion.[123]

   simple-condition-format-control
      error.1 error.4 cerror.1 cerror.4

   synonym-stream-symbol:
      synonym-stream-symbol.1 synonym-stream-symbol.error.[12]

   broadcast-stream-streams:
      broadcast-stream-streams.[12]
      broadcast-stream-streams.error.[12]

   two-way-stream-input-stream:
      two-way-stream-input-stream.1
      two-way-stream-input-stream.error.[12]

   two-way-stream-output-stream:
      two-way-stream-output-stream.1
      two-way-stream-output-stream.error.[12]

   echo-stream-input-stream:
      echo-stream-input-stream.1
      echo-stream-input-stream.error.[12]

   echo-stream-output-stream:
      echo-stream-output-stream.1
      echo-stream-output-stream.error.[12]

   concatenated-stream-streams:
      concatenated-stream-streams.[12345]
      concatenated-stream-streams.error.[12]

   make-load-form-saving-slots:
      make-load-form-saving-slots.[123456789]
      make-load-form-saving-slots.1[012]
      make-load-form-saving-slots.error.[12]

   pprint-indent
      pprint-indent.[123456789] pprint-indent.1[0123456789]
      pprint-indent.13a pprint-indent.2[0123]
      pprint-indent.error.[123]

   pprint-newline
      pprint-newline.[123] pprint-newline.linear.[123456789]
      pprint-newline.linear.10 pprint-newline.miser.123456789]
      pprint-newline.miser.1[0123] pprint-newline.fill.[123456789]
      pprint-newline.fill.10 pprint-newline.mandatory.[123456]
      pprint-newline.error.123] pprint-newline.error.1-unsafe

   pprint-tab
      pprint-tab.non-pretty.[12345678] pprint-tab.nil.1
      pprint-tab.t.1 pprint-tab.line.1 pprint-tab.section.1
      pprint-tab.line-relative.1 pprint-tab.section-relative.1
      pprint.tab.error.[1234]

   
      

21. The following macros are missing: define-compiler-macro
    define-setf-expander define-symbol-macro in-package.
    ansi-tests: cl-macro-symbols.1 in-package.error.1
    dcf-macros define-setf-expander.error.1
    define-setf-expander.[1234567] define-compiler-macro.error.[123]
    define-compiler-macro.[12345678] define-symbol-macro.error.[123]

22. GENTEMP should take a package designator as its second argument,
   not just a package object. ansi-tests: gentemp.[345].

23. (special-operator-p 'symbol-macrolet) should be true.
   ansi-tests: special-operator-p.1

24. (debatable) special-operator-p should be nil on DECLARE and IN-PACKAGE.
   ansi-tests: special-operator-p.2

25. (debatable) "USER" should not be a nickname of "COMMON-LISP-USER"
     (instead, it can name a separate package).
    ansi-tests: common-lisp-user-package-nicknames

26. FIND-ALL-SYMBOLS should take a string designator, which includes
    character values.  ansi-tests: find-all-symbols.2

27. Free special declarations do not apply to the final value clauses
    of iteration forms.  ansi-tests: do-symbols.16 do-external-symbols.16

28. The scope of the bound variable in DO-ALL-SYMBOLS should include
    the final value form.  ansi-tests: do-all-symbols.4

29. The implicit block in DO-ALL-SYMBOLS should surround the entire
    loop, including the return value form.  ansi-tests: do-all-symbols.6

30. DO-ALL-SYMBOLS should accept declarations. ansi-tests: do-all-symbols.9
    do-all-symbols.10 do-all-symbols.11

31. IMPORT should set the home package of any symbol being imported that
    does not have a home package.  ansi-tests: import.5

32. The setf expander for VALUES evaluates the source form before the subforms
    of the destination places.  ansi-tests: setf-values.5

33. Order of evaluation problem in expansion of psetq/psetf, possibly involving
    symbol macros.  ansi-tests: psetq.7 psetf.7

34. Cannot create classes whose names are uninterned symbols.
    ansi-tests: psetf.35 rotatef.35 defclass.forward-ref.4

35. ROTATEF does not work with no arguments.  snsi-tests: rotatef.3

36. DEFSETF (long form) should produce an implicit block with the name
    of the accessor-fn.  ansi-tests: defsetf.5a

37. The expansion function produced by DEFSETF (long form) should be defined
    in the same lexical environment in which the DEFSETF form appears.
    ansi-tests: defsetf.6a

38. The control error signaled by (throw (gensym) nil) isn't printable
    when *print-escape* and *print-readably* are nil. ansi-tests: throw-error

39. DOCUMENTATION should be allowed to be called on function objects, not
    just function names. ansi-tests: define-modify-macro.documentation.1
    define-modify-macro.documentation.2

40. In DEFUN where the function names is a (SETF <name>) pair, there is an
    implicit block with name <name>.  ansi-tests: defun.4

41. Free special declarations do not apply to the expressions in &aux,
    &optional or &key forms of an ordinary lambda list.  See also bug #49.
    ansi-tests: defun.5 defun.6 defun.7

42. &WHOLE causes an error during macroexpansion in destructuring-bind.
    ansi-tests: destructuring-bind.20
    
43. destructuring-bind fails to destructure in the &rest parameter
    ansi-tests: destructuring-bind.21

44. The macro function for destructuring-bind (and, I suspect, many
    other builtin macros) fails to properly signal a program error
    when called on an invalid number of arguments.  ansi-tests:
    destructuring-bind.error.[789]

45..No hash table with :key EQUALP.
    ansi-tests:  equalp.21

46. EQUALP fails to properly compare hash tables.
    ansi-tests: equalp.22 to equalp.35

47. The type error signaled by EVERY and related functions has
    the datum and expected-type slots switched.  ansi-tests:
    every.error.1 notany.error.1  notevery.error.1 some.error.1

48. flet and labels do not accept SETF function names.
    ansi-tests: flet.17 labels.17 flet.51 labels.26

49. Free special declarations in flet and labels forms do not affect
    the expressions in the &aux, &optional and &key fields of the
    ordinary lambda list.  See also bug #41.  ansi-tests: flet.62 flet.63
    flet.67 labels.41 labels.42 labels.46

50. Funcall should throw an undefined function error when called on a symbol
    that has a macro function binding but not a function binding.
    ansi-tests: funcall.error.3

51. function-lambda-expression is not defined.
    ansi-tests: function-lambda-expression.[123]
    function-lambda-expression.order.1 function-lambda-expression.error.[12]

52. Lambda forms are no longer of type function.
    ansi-tests: function.6 function.10 functionp.6 functionp.10

53. Symbols are no longer functions.
    ansi-tests: functionp.2

54. Free special declarations do not apply to the init forms of a LET or LET*.
    ansi-tests: let.17 let.17a let*.17 let*.17a let*.18

55. &whole not recognized in macro lambda list
    anso-tests: macrolet.5 macrolet.36 defmacro.7

56. symbol-macros are not showing up in the macro expansion environment
    ansi-tests: macrolet.13 macrolet.14 

57. :allow-other-keys not being properly handled in macros with &key in
    their macro lambda lists.  ansi-tests: macrolet.32 defmacro.21

58. NIL should match anything in a macro lambda lists.
    ansi-tests: macrolet.39

59, Ordering problem related to presence of symbol macro with side effects
    in multiple-value-setq.  ansi-tests: multiple-value-setq.[58]

60. Free special declarations should not apply to the initialization
    forms in PROG, PROG* forms.  ansi-tests: prog.11 prog*.11

61. DEFINE-COMPILER-MACRO is undefined

62. DEFINE-SYMBOL-MACRO is undefined

63. CONSTANTP should take an optional second argument, an environment
    or nil (and which may be ignored.)  ansi-tests: constantp.6
    constantp.8 constantp.order.2

64. Free special declarations in a LAMBDA form should not affect
    the expressions in key, aux, or optional parameters.
    ansi-tests: lambda.52 lambda.53 lambda.55

65. The second argument to COMPILE is allowed to be a function;
    not just a lambda expression.  ansi-tests: lambda.55 lambda.56

66. COMPILE-FILE is incorrectly executing the code twice i
     an EVAL-WHEN form with both the :COMPILE-TOPLEVEL and
    :LOAD-TOPLEVEL keywords.  ansi-tests: eval-when.1

67. DEFMACRO is not defining the macro function in the lexical
    environment in which the DEFMACRO form appears.
    ansi-tests: defmacro.3 defmacro.4 defmacro.12 defmacro.13

68. (typep nil (find-class 'null)) ==> nil
    See also bug #81.
    ansi-tests: the.9 the.10

69. (VALUES &REST ...) not being understood.
    ansi-tests: the.14 the.15 the.18 the.21 the.22

70. (THE (VALUES ... &OPTIONAL ...) (EVAL '(VALUES ...))) is
    signaling a spurious error.  ansi-tests: the.20 the.23

71. SYMBOL-MACROLET does not admit DECLARE expressions.
    ansi-tests: symbol-macrolet.3 symbol-macrolet.8
    symbol-macrolet.error.1 

72. SYMBOL-MACROLET should signal a program error when
    the symbol is a constant or special variable, but it does not.
    ansi-tests: symbol-macrolet.error.1 symbol-macrolet.error.2

73. MACRO-FUNCTION should take an optional second argument (that
    is an environment or NIL), but it does not.
    ansi-tests: macro-function.[2379] macro-function.1[135]
      loop-finish.error.1

74. SUBTYPEP problems (ansi-tests: types.3)

   a. GENERIC-FUNCTION FUNCTION ==> NIL T
   b. UNBOUND-SLOT CELL-ERROR ==> NIL T
      (see also unbound-slot-cpl)
   c. FLOATING-POINT-INVALID-OPERATION ARITHMETIC-ERROR ==> NIL T
      (see also floating-point-invalid-operation-cpl type-of.5)
   d. FLOATING-POINT-INEXACT ARITHMETIC-ERROR ==> NIL T
      (see also floating-point-inexact-cpl type-of.5)
   e. LOGICAL-PATHNAME PATHNAME ==> NIL T
   f. PRINT-NOT-READABLE ERROR ==> NIL T
      (see also print-not-readable-cpl)
   g. READER-ERROR PARSE-ERROR ==> NIL T
      (see also reader-error-cpl)
   h. READER-ERROR STREAM-ERROR ==> NIL T

   (see also condition.2 for subtype failures on expected subtype
    relationships of condition types)

75. More SUBTYPEP problems (ansi-tests: types.9a)

   a. VECTOR SIMPLE-ARRAY ==> T T
   b. ARRAY SIMPLE-ARRAY ==> T T
   c. BIT-VECTOR SIMPLE-ARRAY ==> T T
   d. BIT-VECTOR SIMPLE-BIT-VECTOR ==> T T

   (counterexample elements were found for all these supposed subtype
    relationship.)

76. (subtypep 'function 'atom) ==> T T (which is correct), but there
    are function objects that are not of type atom.  The problem is that
    cons cells are used to represent functions.  The problem is tbat
    lambda expressions are no longer of type FUNCTION in CLtS.
    (also from ansi-test types.9a, see also
     universe-elements-in-at-most-one-disjoint-type)

77. Yet more SUBTYPEP problems:
     (subtypep 'standard-object (find-class 'standard-object)) ==> nil t
    ansi-tests: all-classes-are-type-equivalent-to-their-names

78. A number of standardized classes are implemented as structure
    classes (which is allowed) but subtypep is not recognizing them
    as subtypes of structure-object:  synonym-stream, hash-table,
    broadcast-stream,  echo-stream, pathname, concatenated-stream,
    readtable, function, file-stream, string-stream, stream, package,
    two-way-stream.
    ansi-tests: all-structure-classes-are-subtypes-of-structure-object

79. The standardized generic function DOCUMENTATION should be a member
    of the class GENERIC-FUNCTION.

80. SUBTYPEP is not correctly determining that if a class X is a subclass
    of classes Y and Z, then X is a subtype of (AND Y Z) (it is allowed
    to fail to determine the subtype relationship, but if it does it must
    determine it correctly).  ansi-tests: tac-3.16

81. (let ((x (make-condition 'arithmetic-error))) (typep x (class-of x)))
      ==> NIL
    More generally, typep isn't working on class object type specifiers.
    ansi-tests: coerce.3 class-28.[123] class-0201.1 class-0202.1
     class-0301.1 class-0309.1 class-0311.1 allocate-instance.[1234]
     allocate-instance.order.1 change-class.3.[12]
     update-instance-for-different-class.4

82. In a DEFTYPE lambda list, the default value for missing key or optional
    parameters should be the symbol *, not NIL.
    ansi-tests: deftype.11 deftype.12 deftype.18

83. SUBTYPEP is not correctly handling a DEFTYPE that yields the NIL type:
     (deftype foo () nil)
     (subtypep '(foo) nil) ==> nil t
    ansi-tests: deftype.13

84. The body of a DEFTYPE form should be in an implicit block whose name
    is the name of the type being defined.
    ansi-tests: deftype.16

85. DEFTYPE forms are not allowing all DECLARE expressions.
    ansi-tests: deftype.19

86. Free special declarations in a DEFTYPE should not apply to the
    forms in optional or key arguments in the deftype lambda list.
    ansi-tests: deftype.15

87. The method parameter specifier (X FUNCTION) is not matching
    the function value #'CONS.
    ansi-tests: standard-generic-function.[12]

88. Numerous problems with TYPE-OF (ansi-tests: type-of.1 type-of.4)

   a. TYPE-OF of a nonnegative integer must be a subtype of UNSIGNED-BYTE.
   b. #\Rubout, #\Tab, #\Backspace, #\Return, and #\Page are BASE-CHARs,
      and have TYPE-OF ==> STRING-CHAR,  but
       (SUBTYPEP 'STRING-CHAR 'BASE-CHAR) ==> nil t
   c. TYPE-OF on condition objects returns PCL::STD-INSTANCE, which is
      not a subtypep of the condition types to which the objects belong.
      It also isn't a subtype of the class returned by CLASS-OF.
   d, TYPE-OF on #(nil nil) is VECTOR, but #(nil nil) is a SIMPLE-VECTOR.
   e. TYPE-OF on a logical pathname returns PATHNAME, which is not a subtype
      of LOGICAL-PATHNAME.
   f. TYPE-OF on standard methods returns PCL::STD-INSTANCE, which is not
      a subtype of METHOD, STANDARD-METHOD, OR STANDARD-OBJECT.
      It is also not a subtype of (CLASS-OF <method>).
   g. TYPE-OF on a compiled closure for a generic function yields
      COMPILED-FUNCTION, which is not a subtype of GENERIC-FUNCTION,
      STANDARD-GENERIC-FUNCTION, or STANDARD-OBJECT.  It is also not
      a subtype of (CLASS-OF <fun>).

  (Note: in f and g, the STANDARD-OBJECT is there because these entities
   are elements of this type in gcl, although this is not required by
   the standard.  Given that they are elements, the subtype relationship
   is required by the standard.)

89. TYPE-OF on an instance of a user-defined standard class is
    PCL::STD-INSTANCE, but it should be the name of the class
    (or the class itself if it has no name).
    ansi-tests: type-of.7 type-of.8 type-of.9 (and type-of.10,
    indirectly)

90. typep should signal an error if the type is a VALUES type.
    ansi-tests: typep.error.4 typep.error.5 typep.error.6

91. typep should signal an error if the type is a compound function
    type.  ansi-tests: typep.error.7

92. The CPL (class precedence list) tests are failing due to a bug
    in PCL that also showed up in SBCL and CMUCL.  The function starts
    returning NIL after a few calls.  ansi-tests: *-CPL

93. READTABLE-CASE is undefined (and its SETF form)
    ansi-tests: read-symbol.1[678] read-symbol.25
     readtable-case.* set-syntax-from-char-trait-*
     print.symbol.[123456789] print-symbol.1[012] prin1.symbol.[123]
     

94. Binding *READ-SUPPRESS* to true doesn't totally suppress reading;
    reading a list still returns a list, as does reading a vector
    or pathname.
    ansi-tests: read-suppress.9 read-suppress.1[01245]
    read-suppress.sharp-quote.[1235678]
    read-suppress.sharp-left-paren.[123456789]
    read-suppress.sharp-left-paren.1[012]
    read-suppress.sharp-p.[1234567]
    read-suppress.sharp-equal.4
    

95. Binding *READ-SUPPRESS* to true causes the reading of complex
    numbers to abort with a type error.
    read-suppress.sharp-c.[123456789] read-suppress.sharp-c.1[12345]

96. In read suppressed mode, #r does not read the full token following
    it, but stops at the # character.  ansi-tests: read-suppress.sharp-r.10

97. In read suppressed mode, ## terms are not read correctly
    ansi-tests: read-suppress.sharp-sharp.[1234]

98. Reading a token starting with a right paren (an invalid character)
    should signal a READER-ERROR, but it does not.
    ansi-tests: read-suppress.error.1 syntax.right-paren-error.1

99. Reading #< should signal a reader error.
    ansi-tests: read-suppress.error.2 set-syntax-from-char.right-paren
     syntax.sharp-less-than.1

100. Setting the syntax of a character to that of #\" doesn't work.
    ansi-tests: set-syntax-from-char.double-quote

101. Initially, for a new dispatching macro character, every following
    character should have the dispatching macro character function that
    signals a read-error.  This is not happening.
    ansi-tests: make-dispatch-macro-character.3

102. #\Backspace is an invalid character in the standard syntax, and
    reading it should signal a reader-error.  This is not happening.
    ansi-tests: syntax.backspace.invalid

103. #\Rubout is an invalid character in the standard syntax, and
    reading it should signal a reader-error.  This is not happening.
    ansi-tests: syntax.rubout.invalid

104. The string "#0()" should read as the simple vector of length 0,
    but it causes an error. ansi-tests: syntax.sharp-left-paren.2

105. Various malformations of #* syntax should lead to reader errors,
    but do not.  ansi-tests: syntax.sharp-asterisk.error.[123]

106. Binding *read-eval* to nil should cause #. to throw a reader
    error, but it does not always.  ansi-tests: syntax.sharp-dot.error.3

107. #C should tolerate whitespace before the left paren.
    ansi-tests: syntax.sharp-c.5

108. #+(:and) #+(:or) #+(:not ...) lead to errors in the reader (which
    is wrong).  The problem seems to be that the feature expression
    is being read in the current package, not the keyword package.
    ansi-tests: syntax.sharp-plus.5 syntax.sharp-plus.7 syntax.sharp-plus.8
     syntax.sharp-plus.12

109. Reading # followed by whitespace[1] should signal a reader-error,
    but it is not (it is signaling a simple-error that is not a reader-error).
    ansi-tests: syntax.sharp-whitespace.1

110. Reading # followed by a right parenthesis should signal a reader-error,
    but it is not (it is signaling a simple-error that is not a reader-error).
    ansi-tests: syntax.sharp-right-paren.1

111. Reading a rational with zero denominator should signal a reader error.
    ansi-tests: syntax.number-token.error.1

112. Tokens containing only dots and not being a single dot in a position
    where a consing dot is expected should cause a reader-error.
    ansi-tests: syntax.dot-error.[1234567]

113. Reading a comma while not in a backquoted form should signal a
     reader-error.  ansi-tests: syntax.comma-error.[12]

114. Free special declarations in DO, DO* forms should not affect the init
     forms.  ansi-tests: do.16 do*.16

115. NIL is a destructuring pattern that matches anything (and binds
     nothing) and should be allowed in for-as-arithmetic clauses.
     ansi-tests: loop.1.5[013456] 

116. A while or until clause in a LOOP should be executed at its location,
     not earlier.  ansi-tests: loop.11.29 loop.11.3[01234]

117. Creating a structure whose name is an uninterned symbol causes the
     class that is created to be unfindable with FIND-CLASS.
     ansi-tests: struct-test-31/1[3457] struct-test-31/15a

118. The -P predicate created for a structure of type (vector t) causes
     an error on the string (string (code-char 0)).
     ansi-tests: struct-test-41/3 struct-test-43/3

119. There should be an initialization argument :format-control for
     simple-errors and simple-warnigns.  ansi-tests: error.[2389]
     error.1[02] cerror.[23] cerror.2a warn.8 warn.10 warn.19

120. Error should take a formatter (not just a format string) as its first
     argument. ansi-tests: error.5 error.1 cerror.4a cerror.5

121. The datum slot of the error signaled by a CHECK-TYPE failure
     is not the value being checked. ansi-tests: check-type.[23567]

122. invoke-debugger is not signaling a program error in safe code
     when called with an incorrect number of arguments.

123. The (<type> <handler>) pairs of HANDLER-BIND should accept
     literal function values as handlers, but uncompiled function
     objects (which are improperly implemented as CONSes) cause
     an error.  ansi-tests: handler-bind.9

     (This is also a problem with function literals occuring
      in other expressions, but there isn't a test for that
      in the eval/compile section of ansi-tests.)

124. HANDLER-BIND is not properly handing off a declined condition
     to a following handler in some cases.  ansi-tests: handler-bind.11

125. HANDLER-BIND is not accepting condition class objects as type
     designators.  ansi-tests: handler-bind.17

126. HANDLER-CASE is not accepting condition class objects as type
     designators.  ansi-tests: handler-case.5

127. HANDLER-CASE did not accept a DECLARE expression (by itself)
     in the body of a handler clause.  ansi-tests: handler-case.28

128. Free special declarations in the handler clauses of a HANDLER-CASE
     are improperly affecting the expressions in &aux variables.
     ansi-tests: handler-case.29

129. (typep <condition object> (find-class 'condition)) ==> NIL
     (typep <condition object> (find-class '<its condition class name>)) ==> NIL
     ansi-tests: condition-1/is-a-member-of-class/condition and
      about 30 similar tests

130. compute-restarts is returning a restarts that are not associated with
     the condition being tested.  ansi-tests: compute-restarts.9

131. restart-case with macro, symbols forms not not properly handled:
     ansi-tests: restart-case.29 restart-case.30 restart-case.31

132. Free special declarations in restart definitions in restart-case
     do not have the correct scope.  ansi-tests: restart-case.36

133. continue, store-value, and use-value functions are invoking restarts
     that are applicable to other conditions than the argument condition.
     (Or, with-condition-restarts may not be behaving properly)
     ansi-tests: continue.2 store-value.2 use-value.2

134. A safe call (make-condition) should signal a program error.
     ansi-tests: make-condition.error.1

135. Division by zero should be signaling a divide-by-zero condition,
     not a generic simple error.  ansi-tests /.error.[2345678]

136. (/ -1) is returning three values, not just one.
     ansi-tests: /.2

137. (expt -1 0.0) should be 1.0 (of the appropriate floating type),
     but the result being returned is #c(1.0 0.0).
     ansi-tests: expt.18 expt.19 expt.20 expt.21

138. (lcm) should yield 1, not an error.
     ansi-tests: lcm.1

139. (typep 1 '(real (0))) ==> error  (and similarly for
        (typep 1 '(integer (0))).)
     ansi-tests: random.error.3

140. (phase 0) ==> error (logarithmic singularity)
     ansi-tests: phase.1

141. (float x) should eql x when x is a float, but short-floats
     are being converted to single-floats
     (eql (float 1.0s0) 1.0s0) ==> NIL
     ansi-tests: float.5

142. rational and rationalize should signal type errors on arguments
     that are not of type real in safe code.
     ansi-tests: rational.error.4 rationalize.error.4

143. Apparent compiler problem in this function:

     (defun digit-char.1.body.old ()
       (loop for r from 2 to 36 always
            (loop for i from 0 to 36
               always (let* ((c (digit-char i r))
                             (result
                              (if (>= i r) (null c)
                                  (eqlt c (char +extended-digit-chars+ i)))))
                        (unless result
                          (format t "~A ~A ~A~%" r i c))
                        result))))

      When called, it prints  2 2 p and returns nil.  However,
      (digit-char 2 2) ==> nil when called at the REPL.

      (this is from digit-char.1, but that test has been changed.)

144. digit-char should take at most two arguments, but it is failing
     to signal a program error in safe code when given more.
     ansi-tests: digit-char.error.2

145. standard-char-p should signal a type error in safe code when
     called on a non-character.  ansi-tests: standard-char-p.3

146. code-char should signal an error in safe code when called with
     more than one argument.  ansi-tests: code-char.error.2

147. adjust-array does not have the correct semantics when performed
     on the middle of a chain of three displaced bit vectors.  The chain
     appears to have been improperly short-circuited.
     ansi-tests: adjust-array.bit-vector.adjustable.13

148. fill-pointer should signal a type error when called with vectors
     that lack fill pointers.  It does, but the expected-type field
     is wrong.  ansi-tests: fill-pointer.error.[36]

149. The value (upgraded-array-element-type 'base-char) should be
     type-equivalent to base-char.  However, it is string-char,
     and (subtypep 'string-char 'base-char) ==> nil t
     ansi-tests: upgraded-array-element-type.2

150. upgraded-array-element-type violates the 'preserves subtype'
     properties for numerous types.  For example:

      (upgraded-array-element-type '(eql 2)) ==> lisp:signed-char
      but
      (upgraded-array-element-type '(unsigned-byte 16)) ==>
             lisp:unsigned-short

     ansi-tests: upgraded-array-element-type.8

151. (upgraded-array-element-type nil) ==> t, but it should be nil.

152. vector-pop should signal a type-error when passed a vector
     that lacks a fill pointer.  It does, but the expected-type
     slot is wrong.  ansi-tests: vector-pop.error.[15]

153. (make-hash-table :size 0) signals an error, but 0 is a legal
     value for the size parameter.  ansi-tests: make-hash-table.2

154. equalp hash tables are not supported.
     ansi-tests: make-hash-table.1[01] hash-table-count.[59]
     hash-table-rehash-threshold.[23] hash-table-test.[234]
     gethash.zero.4 remhash.4 clrhash.4 maphash.[36]
     with-hash-table-iterator.7
 
155. (make-hash-table :rehash-threshold x) errors:

    a. x == 0 (or 0.0s0, or 0.0)  signals an error, but zero
     is a legal value for this parameter.  ansi-tests:
     make-hash-table.1[6789] make-hash-table.20
     
    b. x == 1/2 signals an error, but this is a legal value for
     this parameter.  ansi-tests: make-hash-table.21

156. The third argument to GETHASH in the SETF form should be
    allowed, but instead is causing an error.
    ansi-tests: gethash.5 gethash.order.4

157. The last invocation of the local macro in WITH-HASH-TABLE-ITERATOR
    should return just a single value, NIL, but it is returning
    three values.  ansi-tests: with-hash-table-iterator.4

158. PATHNAME, when called on a stream, should return the pathname
    that was used to create the stream.  However, for logical pathnames,
    this is not happening -- the physical pathname corresponding to the
    logical pathname is returned instead.
    ansi-tests: logical-pathname.3

159. ensure-directories-exist should signal a file-error if part of
    the directory is wild, but it does not.
    ansi-tests: ensure-directories-exist.error.1

160. stream-element-type is returning :default on a stream opened
    with OPEN.  This violates the constraint that this type must
    be a subtype of integer or character.  ansi-tests: stream-element-type.6

161. Cannot write (1- (ash 1 32)) to a stream with :element-type
    (unsigned-byte 32) using write-byte. ansi-tests: read-byte.3
     read-byte.4 file-length.[2345]

162. peek-char advances the file position of echo streams.
     ansi-tests: peek-char.17

163  Passing NIL to the :start argument of read-sequence or write-sequence
     is treated as if the parameter were not present.  This is incorrect:
     :start, if provided, must be a nonnegative integer, and should signal
     a type error in safe calls otherwise..  ansi-tests:
     read-sequence.error.9 write-sequence.error.15

164. file-string-length is computing the wrong thing.  It should compute
     the change in file position after an object is printed as a sequence
     of characters, not as printed in readable representation.  #\a, for
     example, should occupy one position, not three.
     ansi-tests: file-string-length.[12]

165. Free declarations in with-open-file forms should not have the return
     value form in their scope.  ansi-tests: with-open-file.[789]

166. open-stream-p reports that a string-stream (input or output)
     is still open, even after it has been closed.  ansi-tests:
     with-open-stream.[6789]

167. Free declarations in a with-open-stream form are incorrectly
     being applied to the return value form.  ansi-tests: with-open-stream.10

168. (typep (make-broadcast-stream) 'broadcast-stream) ==> nil (and related).
     ansi-tests: make-broadcast-stream.[123]

169. file-position should return 0 on null broadcast streams.
     ansi-tests: make-broadcast-stream.6

170. file-string-length should return 1 on null broadcast streams.
     ansi-tests: make-broadcast-stream.7

171. make-broadcast-stream should signal a type error in safe calls
     when an argument is not an output stream.
     ansi-tests: make-broadcast-stream.error.[12]

172. open-stream-p returns T on a two-way-stream, echo-stream,
     or concatenated-stream that has been closed.
     ansi-tests: make-two-way-stream.2 make-echo-stream.10
      make-concatenated-stream.27

173. make-two-way-stream should signal a type error if the output
     stream argument is not an output stream.  It does so, but
     the expected-type slot is wrong.
     ansi-tests: make-two-way-stream.error.[67]

174. (open-stream-p (make-concatenated-stream)) ==> nil
     ansi-tests: make-concatenated-stream.7

175. READ-CHAR-NO-HANG is encountering a premature EOF in a concatenated
     stream.  It looks like it is only reading from the first of the input
     streams.
     ansi-tests: make-concatenated-stream.16

176. LISTEN fails to look at the second input stream to a concatenated
     stream.
     ansi-tests: make-concatenated-stream.30

177. make-string-output-stream should take a keyword argument, :element-type.
     ansi-tests: make-string-output-stream.[235679]
      make-string-output-stream.1[01]

178. Free declarations in with-input-from-string should not apply to the return
     value form, or the start or end arguments.
      ansi-tests: with-input-from-string.19 with-input-from-string.2[012]

179. The index place argument of with-input-from-string should be updated only
     if the form terminates normally.
      ansi-tests: with-input-from-string.22

180. with-output-to-string should take an :element-type argument.
      ansi-tests: with-output-to-string.[78] with-output-to-string.1[46]

181. Free special declarations in with-output-to-string should not
     apply to the return value form.
      ansi-tests: with-output-to-string.15

182. Calling make-instance with an initialization argument for a shared slot
     does not properly initialize that shared slot.
     ansi-tests: class-13.1

183. Violations of the rules for default initargs.
     ansi-tests: class-20.[123] class-21.[1245]

184. documentation doesn't work on class objects.
     ansi-tests: class-23.[34]

185. :ALLOW-OTHER-KEYS <true> in the :DEFAULT-INITARGS specifier of
     a class definition should allow other arguments to be passed in
     the initializer list to make-instance.  However, this is not happening.
     ansi-tests: class-24.2

186. slot-makunbound should return the instance. It is instead returning nil.
     ansi-tests: class-0203.[12] slot-missing.3

187. slot-makunbound throws an error incorrectly:


> (defclass example-class () ((a :allocation :instance)
                              (b :allocation :class)))

#<Standard-Class EXAMPLE-CLASS 72244360>

> (let ((c1 (make-instance 'example-class))) (slot-makunbound c1 'a))

Error in LET [or a callee]: What kind of instance is this?

     ansi-tests: class-0206.1 class-0207.1 class-redefinition.2
      update-instance-for-different-class.[123] slot-boundp.5
      slot-makunbound.[12] slot-makunbound.error.[12]
      
188. T is an illegal documentation type.
    ansi-tests: class-0221.[123] defgeneric.2

189. If the name of a class is changed to NIL, and another class of the same
    original name is then defined, the original class should not be redefined;
    instead, there should be two classes.  Zee section 4.3.1 for the notion
    of 'proper name', and see also bug #190 below.
    ansi-tests: class-0309.1

190. Similar to 189, but if FIND-CLASS for a given name is changed.
    ansi-tests: class-0310.1

191. defclass should allow forward referencing of superclasses, but
    doesn't.  Attempting to include the name of a class that hasn't
    yet been defined in the superclass list causes an error.
    ansi-tests: defclass.forward-ref.[123]

192. ensure-generic-function should take a method class object as its
    :method-class argument.
    ansi-tests: ensure-generic-function.9

193. ensure-generic-function should take the :declare keyword argument,
    but it does not (this was a source of some confusion in other lisps,
    and may be a spec bug.)
    ansi-tests: ensure-generic-function.13

194. allocate-instance should work on structure classes.
    ansi-tests: allocate-instance.5

195. allocate-instance should signal a program-error when called with
    too few arguments in safe code.
    ansi-tests: allocate-instance.error.1

196. change-class isn't allowing the :allow-other-keys keyword argument.
    ansi-tests: change-class.1.7 change-class.7.5

197. When SLOT-MISSING is called when attempting to write to a missing
    slot, any of its return values should be ignored.  However, they
    are being returned by the setf function.
    ansi-tests: slot-missing.[267]

198. When slot-boundp is invoked on a missing slot, only a value equivalent
    (in the boolean sense) to the primary value of slot-missing should
    be returned, not any other values.
    ansi-tests: slot-missing.8

199. If slot-value is called on an unbound slot, and the applicable
     slot-unbound method returns no values, then slot-value should return
     the primary value, which is NIL.  However, it is returning no values
     at all.  Similarly, if the method returns more than one value, slot-value
     should return only the first
    ansi-tests: slot-unbound.[3456]

200. The function method-qualifiers should throw a progra-error when called
     with other than one argument in safe code.
    ansi-tests: method-qualifiers.error.[12]

201. remove-method must not signal an error if the method does not belong
     to the generic function.
    ansi-tests: remove-method.1

202. MAKE-LOAD-FORM should have default methods (that signal errors) when
     invoked on standard objects, structure objects, or conditions.
    ansi-tests: make-load-form.[456789] make-load-form.1[012]

203. MAKE-LOAD-FORM should signal a program error when invoked with too
     many arguments.
    ansi-tests: make-load-form.error.2

204. WITH-ACCESSORS forms should allow the presence of DECLARE expressions.
    ansi-tests: with-accessors.1[01]

205. WITH-SLOTS forms should allow the presence of DECLARE expressions.
    ansi-tests: with-slots.19 with-slots.20

206. DEFGENERIC should signal a program=error if a required argument occurs
     more than once in the argument-precedence-order list, or if a
     required argument is missing in the argument-precedence-order list.
    ansi-tests: defgeneric.error.[48]

207. If a generic function is passed a keyword argument that is not
     accepted by any applicable method, an error should be signalled.
     See CLtS 7.6.5.
    ansi-tests: defgeneric.error.2[01]

208. When an existing generic function is redefined using DEFMETHOD, any
     preexisting methods that were defined using the :methods option
     of DEFGENERIC should be removed.  See also paragraph 4 of the
     description of ENSURE-GENERIC-FUNCTION.

    ansi-tests: defgeneric.3[12]

209. The method declarations in DEFGENERIC forms should admit DECLARE
     expressions.
    ansi-tests: defgeneric.35

210. Neither rebinding nor using SETQ (& related operators) should alter
     the arguments passed by CALL-NEXT-METHOD.
    ansi-tests: call-next-method.8

211. "When providing arguments to call-next-method, the following
      rule must be satisfied or an error of type error should be signaled:
      the ordered set of applicable methods for a changed set of arguments
      for call-next-method must be the same as the ordered set of applicable
      methods for the original arguments to the generic function."

   ansi-tests: call-next-method.error.[12]

212. COMPUTE-APPLICABLE-METHODS should signal a program-error when called
     with too many or too few arguments in safe code.
   ansi-tests: compute-applicable-methods.error.1

213. FIND-METHOD should signal a program-error when called with too few
     or too many arguments.
   ansi-tests: find-method.error.[1234]

214. FIND-METHOD should signal an error if the length of the specializers
    list does not equal the number of required arguments to the generic
    function
   ansi-tests: find-method.error.[789] find-method.error.10

215. ADD-METHOD should signal a program-error when called with too few or
     too many arguments in safe code.
    ansi-tests: add-method.error.[456]

216. ADD-METHOD should return the generic function.
    ansi-tests: add-method.[12]

217. Computing SLOT-VALUE on a missing slot should throw an UNBOUND-SLOT error.
    ansi-tests: unbound-slot.[12]

218. A generic function should throw a program-error if called with too few
     or too many arguments in safe code.
    ansi-tests: defmethod.error.1[34]

219. A generic function should throw a program-error when called with invalid
     keyword arguments in safe code.
    ansi-tests :defmethod.error.15

220. Double floats are not printed readably correctly.  Round-off error
     is apparently occuring, causing the re-read value to differ slightly.
    ansi-tests: print.double-float.random print.long-float.random

221. #\Space should print (under PRIN1) as #\ , not #\Space.
    ansi-tests: print.char.4 print.char.10

222. Escaped haracter printing violates therules in 2.4.8.1
    ansi-tests: print.char.7

223. (code-char 28) doesn't print or possibly read correctly
    ansi-tests: print.char.[89]

224. A symbol whose symbol-package is a deleted package should be printed
     as if it had no home package.
    ansi-tests: print.symbol.prefix.8

225. Component printing controlled by *print-level* should not print #
     for an object unless that object 'has components'.  I interpret
     this to mean objects that are printed by recursive calls to the
     object printer, and that can be targets of #n# syntax, so cons cells,
     T vectors, structures, etc. have components, but not numbers, symbols.
     strings, or bit vectors.
    ansi-tests: print.cons.level.[25] print.vector.level.[34] pprint.1
      print-level.[4589]

226. Arrays of dimension > 1 that have total size > 0 and one ore more
     dimensions of size 0 do not print readably.
    ansi-tests: print.array.2.2[123]

227. The 'is-similar*' generic function is not dispatching properly.
     In particular, the correct method is apparently not being invoked
     on pathnames.
    ansi-tests: print.pathname.1

228. PPRINT-FILL should signal a program-error when called with the
     wrong number of arguments in safe code.
    ansi-tests: pprint-fill.error.[123]

229. PPRINT-LINEAR should signal a program-error when called with the
     wrong number of arguments in safe code.
    ansi-tests: ppprint-linear.error.[123]

230. PPRINT-TABULAR should use WRITE to print an object when it is a
     non-list.
    ansi-tests: pprint-tabular.[12]

231. The default tabsize for PPRINT-TABULAR is 16, but it is instead
     using ordinary tab characters.
    ansi-tests: pprint-tabular.[6789] pprint-tabular.1[0123456789]
      pprint-tabular.2[01234]

232. PPRINT-TABULAR fails to break the list across lines if it would
     otherwise exceed *PRINT-RIGHT-MARGIN*.
    ansi-tests: pprint-tabular.2[12]

233. PPRINT-TABULAR should signal a program-error when called with the
     incorrect number of arguments in safe code.
    ansi-tests: pprint-tabular.error.[1234]

234. PPRINT-LOGICAL-BLOCK does not always properly print the #n# notation
     when *print-circle* is true.
    ansi-tests: pprint-logical-block.17

235. The local macro PPRINT-EXIT-IF-LIST-EXHAUSTED isn't being defined
     inside PPRINT-LOGICAL-BLOCK forms.
    ansi-tests: pprint-exit-if-list-exhausted.[1234]

236. The local macro PPRINT-POP isn't being defined inside
     PPRINT-LOGICAL-BLOCK forms.
    ansi-tests: pprint-pop.[123456789]

237. PRINT-UNREADABLE-OBJECT, when :TYPE is T, is specified to print a space
     after the type even if nothing else is printed before the closing >.
     This is not happening.  (Arguably this is a spec bug.)  Similarly,
     it is specified to print a space before the 'identity' inforamtion.
    ansi-tests: print-unreadable-object.[23]

238. PRINT-UNREADABLE-OBJECT should signal an error of type PRINT-NOT-READABLE
     if *PRINT-READABLY* is true, but it is not doing this.
    ansi-tests: print-unreadable-object.error.1

239. PRINT appears to ignore the *PRINT-READABLY* control variable,
    as does PRIN1.  ansi-tests: print.1 prin1.1

240. *PRINT-LEVEL* can be legally bound to any nonnegative integer,
     but an error occurs when it is bound to a bignum.
     ansi-tests: print-level.12

241. *PRINT-LENGTH* can be legally bound to any nonnegative integer,
     but an error occurs when it is bound to a bignum.
     ansi-tests: print-length.7

242. Structures should be printed with their slot names given as keyword
     symbols.
    ansi-tests: print-length.11

243. The format directive ~c should print #\Newline, #\Space, and
     many other characters as the single characters, not as their names,
    ansi-tests: format.c.1  format.c.1a format.r.15 format.d.5
     format.d.11 format.b.5 format.b.11 format.o.5 format.o.11
     format.x.5 format.x.11 format.justify.10

244. The ~:c format directive should print the name of simple, non-graphic
     characters.
    ansi-tests: format.c.4a 

245. The ~@c format directive should print characters in a readable format,
     but this fails on the character with code 28.
    ansi-tests: format.c.5a

246. The function produced by the FORMATTER macro should return the list
     of unconsumed arguments.
    ansi-tests: many formatter tests

247. When the v format parameter of the R format directive gets 'nil',
     it is to be treated as if it were not there, which means ~r should
     print an english number.  It isn't doing this.
    ansi-tests: format.r.8

248. Specifying a very large negative format parameter for ~r (and others)
    causes the error 'Can't extend the string.'.  ansi-tests: format.r.38
    format.d.28 format.b.28 format.o.28 format.x.28

249. ~d is supposed to do the same thing as ~a when called on a non-integer,
     but for several kinds of values it doesn't.
    ansi-tests: format.d.1[89] format.d.2[01]

250. The format directive "~vd" fails when the v parameter is a negative
    bignum, and similarly for other numeric directives (b, etc.)
    ansi-tests: format.d.29 format.b.29 format.o.29 format.x.29

251. The ~_ format directive is not implemented.
    ansi-tests: All format.*_* tests  format.logical-block.1[789]
      format.logical-block.2[14

252. In the ~<...~:> format directive (logical block), 'An error is
     signaled if either the prefix or suffix fails to be a constant
     string or if the enclosed portion is divided into more than three
     segments.'
    ansi-tests: format.logical-block.error.[123456789]
     format.logical-block.error.1[0123456789]
     format.logical-block.error.2[01234]

253. 'An error is signaled if any of these directives[~< ... ~:>]
      is nested within ~<...~>."
    ansi-tests: format.logical-block.error.25

254. 'An error is also signaled if the ~<...~:;...~> form of ~<...~>
      is used in the same format string with [...]  ~<...~:> [...].'
    ansi-tests: format.logical-block.error.2[67]

255. ~< ,,, ~:> should consume the next argument and use it (as a list)
     to supply the arguments used by the directives inside the form.
    ansi-tests: format.logical-block.[1679]
      format.logical-block.1[0345]

256. The : modified to ~<...~:> should cause the prefix and suffix
     strings, if missing, to be "(" and ")", respectively.
    ansi-tests: format.logical-block.[45] format.logical-block.2[0236]
     format.logical-block.escape.[12]

257. If ~:@> terminates a ~< construct, then it should be the case that
     'a fill-style conditional newline is automatically inserted after
      each group of blanks immediately contained in the body (except
      for blanks after a <Newline> directive).'  This is not happening.
    ansi-tests: format.logical-block.2[25]

258. ~@; in ~<...~:> construct isn't setting the per-line-prefix properly.
    ansi-tests: format.logical-block.2[789]


259. The ~i directive hasn't been implemented.
    ansi-tests: format.i.[123456789] format.i.1[0123456]

260. The ~/.../ directive hasn't been implemented.
    ansi-tests: format./.[123456789] format./.1[123456789]

261. Various ~T failures, all similar
    ansi-tests: format.t.[348]

262. ~:T and ~:@T  aren't implemented.
    ansi-tests: format.:t,[123456789] format.:t1[012]
     format.:@t.[12345] format.:@t1[abcd]

263. Two ~<...~> failures (undiagnosed)
    ansi-tests: format.justify.8 format.justify.29

264. Condition (~{ ~}) format directive isn't accepting bignums.
    ansi-tests: format.cond.[46] format.cond:.[46]

265. Conditional format directive with a prefix argument selects
     the wrong clause if the prefix is a bignum.
    ansi-tests: format.cond.12

266. A NIL ~v prefix to [ does not work correctly.
    ansi-tests: format.cond.14 format.cond:.7

267. The format directive ~{~} should take the next argument as a format
     control to be used in the iteration.  This is not happening.
   ansi-tests: format.{.1a format.{.1b format.{.1[569] format.{.2[0123]
     format.:{.[3456]  format.@{.1[23] format.:@{.[45]

268. The ~{ ... ~} directive should be prepared to signal an error of
     type type-error if the argument is not a list.
   ansi-tests: format.{.error.5 format.:@{.error.5

269. ~^ should take format parameters that are bignums, and other
      format parameter problems with that format directive.
   ansi-tests: format.^.(.1[89] format.^.{.2[056789]
    format.^.{.3[0123] format.^.:{.[67] format.^.:{.1[013456]
    format.^.:{.3[89] format.^.@{.19 format.^.@{.2056789]
    format.^.@{.3[0123] format.^.:@{.[67] format.^.:@{.1[01456]
    format.^.:@{.3[89]

270. Large numbers of undiagnosed failures in ~:^ in various forms of
     the iteration directives.
    ansi-tests: format.:^.*
