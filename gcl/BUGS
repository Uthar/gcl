This is a list of bugs that have been found in gcl.  When you fix
a bug, add the notation (FIXED) after the bug number, but leave the
number in place so it isn't reused.

1 (FIXED). (subtypep s 'structure-object) isn't working properly when
  s is a structure class name or a structure class object.
  This is causing 95 ansi-test failures.

2. (sublis x y :test #'fn) is passing the arguments to fn in the
  wrong order.  The problem here is that the :key argument is being
  applied somewhat unusually, making the usual TEST macro not do
  quite the right thing.  ansi-tests: sublis.9 and sublis.10

3. (nsublis x y :test #'fn) is passing the arguments to fn in the
  wrong order. Similar to bug #2.  ansi-tests:  nsublis.10 and nsublis.11

4. (last x n) is incorrectly signaling an error when n is a positive
  bignum.  Instead, it should return x.   ansi-tests: last.11, last.12

5. The map* functions should signal a type error when given an improper
  list.  They do so, but the slots of the type error object don't
  satisfy the property that the value in the datum slot is not of
  the type in the expected-type slot.  ansi-tests: mapc.error.8,
  mapcar.error.8, mapcan.error.8, mapl.error.8, maplist.error.11,
  mapcon.error.8

6. Similar to #5, but the error is for GET-PROPERTIES.  ansi-tests:
   get-properties.error.[456]

7. (SETF (GETF form1 form2 form3) form4) is evaluating the subforms
  in the wrong order: form3 is being evaluated before (the subforms of)
  form1 and form2.  ansi-tests: setf-getf.order.2

8. Similar to #5, but the error is for GETF.  ansi-tests: getf.error.[45]

9. REMF is violating the requirement that the value of the place be
  read out after all the other subforms of the REMF form are computed
  (even the ones to the right of the place form; see section 5.1.3
  of CLtS).  ansi-tests:  remf.order.3

10. Similar to #5, but on ELT when the index is out of range.  Should
  return a type-error with datum == the index and type ==
  `(integer 0 (,(length sequence))) (or NIL if the sequence has length 0).
  ani-tests:  elt.1, elt.1b, elt.2, 

11. There's an internal type error somewhere in the code exercised by
  elt.10 -- the invalid type (integer 0 . 1) is being passed to TYPEP
  (and similarly for elt.14, elt-v.1, elt-v.10, elt-adj-array.1,
   elt-adj-array.10, elt-displaced-array.1, elt-fill-pointer.[3468],
   and elt,error.[45]).

12. Coerce can't coerce a vector of characters into a base-string.
  ansi-tests: fill.string.10

13. MAKE-SEQUENCE fails on type argument NULL,. (CLASS-OF NIL), or LIST.
   ansi-tests: make-sequence,9, make-sequence.49. make-sequence.57

14. The datum and expected type fields of the type errors thrown by
   MAKE-SEQUENCE, MAP  do not satisfy the constraint that the datum
   is not of type expected-type.  ansi-tests: make-sequence.error.1,
   make-sequence.error.2, make-sequence.error.14, make-sequence.error.16,
   map.error.1, map.error.1a, map.error.11.

15. MAP fails on type argument NULL, (OR (VECTOR 5) (VECTOR 10))
   ansi-tests: map-null.1, map.48

16. NREVERSE is broken on vectors of element type LISP:SIGNED-SHORT

    (let ((v (make-array '(7) :initial-contents '(1 1 0 1 1 1 0)
                  :element-type 'lisp:signed-short)))
      (nreverse v))
    ==> #(0 1 1 1 1 1 0)

   (ansi-tests: nreverse-vector.7, nreverse-vector.8)

17. The setf expander for SUBSEQ returns the wrong value (the entire
   vector is returned rather than the aubsequence being assigned.)
   ansi-tests: subseq.order.[34]

18. CONCATENATE fails on type argument of NULL, as does MERGE.
   ansi-tests:. concatenate.24, merge-null.1, merge.error.6

19, There are 140 symbols exported from the COMMON-LISP package that
   should not be external in that package.
   ansi-tests: no-extra-symbols-exported-from-common-lisp
    all-exported-cl-class-names-are-valid

20. 19 functions are missing: arithmetic-error-operands
  broadcast-stream-streams cell-error-name concatenated-stream-streams
  echo-stream-input-stream echo-stream-output-stream
  function-lambda-expression get-setf-expansion
  make-load-form-saving-slots pprint-indent pprint-newline
  pprint-tab print-not-readable-object simple-condition-format-control
  synonym-stream-symbol two-way-stream-input-stream
  two-way-stream-output-stream unbound-slot-instance
  compiler-macro-function readtable-case.

  ansi-tests: cl-function-symbols.1, dcf-funs and these tests:

   cell-error-name:
      symbol-value.error.5 symbol-function.error.5 makunbound.2
      eval.error.3 eval.error.4 cell-error-name.[123456]
      cell-error-name.error.[12]

   get-setf-expansion
      get-setf-expansion.error.[12] get-setf-expansion.[123]

   simple-condition-format-control
      error.1 error.4 cerror.1 cerror.4

   synonym-stream-symbol:
      synonym-stream-symbol.1 synonym-stream-symbol.error.[12]
      

21. The following macros are missing: define-compiler-macro
    define-setf-expander define-symbol-macro in-package.
    ansi-tests: cl-macro-symbols.1 in-package.error.1
    dcf-macros define-setf-expander.error.1
    define-setf-expander.[1234567] define-compiler-macro.error.[123]
    define-compiler-macro.[12345678] define-symbol-macro.error.[123]

22. GENTEMP should take a package designator as its second argument,
   not just a package object. ansi-tests: gentemp.[345].

23. (special-operator-p 'symbol-macrolet) should be true.
   ansi-tests: special-operator-p.1

24. (debatable) special-operator-p should be nil on DECLARE and IN-PACKAGE.
   ansi-tests: special-operator-p.2

25. (debatable) "USER" should not be a nickname of "COMMON-LISP-USER"
     (instead, it can name a separate package).
    ansi-tests: common-lisp-user-package-nicknames

26. FIND-ALL-SYMBOLS should take a string designator, which includes
    character values.  ansi-tests: find-all-symbols.2

27. Free special declarations do not apply to the final value clauses
    of iteration forms.  ansi-tests: do-symbols.16 do-external-symbols.16

28. The scope of the bound variable in DO-ALL-SYMBOLS should include
    the final value form.  ansi-tests: do-all-symbols.4

29. The implicit block in DO-ALL-SYMBOLS should surround the entire
    loop, including the return value form.  ansi-tests: do-all-symbols.6

30. DO-ALL-SYMBOLS should accept declarations. ansi-tests: do-all-symbols.9
    do-all-symbols.10 do-all-symbols.11

31. IMPORT should set the home package of any symbol being imported that
    does not have a home package.  ansi-tests: import.5

32. The setf expander for VALUES evaluates the source form before the subforms
    of the destination places.  ansi-tests: setf-values.5

33. Order of evaluation problem in expansion of psetq/psetf, possibly involving
    symbol macros.  ansi-tests: psetq.7 psetf.7

34. Cannot create classes whose names are uninterned symbols.
    ansi-tests: psetf.35 rotatef.35

35. ROTATEF does not work with no arguments.  snsi-tests: rotatef.3

36. DEFSETF (long form) should produce an implicit block with the name
    of the accessor-fn.  ansi-tests: defsetf.5a

37. The expansion function produced by DEFSETF (long form) should be defined
    in the same lexical environment in which the DEFSETF form appears.
    ansi-tests: defsetf.6a

38. The control error signaled by (throw (gensym) nil) isn't printable
    when *print-escape* and *print-readably* are nil. ansi-tests: throw-error

39. DOCUMENTATION should be allowed to be called on function objects, not
    just function names. ansi-tests: define-modify-macro.documentation.1
    define-modify-macro.documentation.2

40. In DEFUN where the function names is a (SETF <name>) pair, there is an
    implicit block with name <name>.  ansi-tests: defun.4

41. Free special declarations do not apply to the expressions in &aux,
    &optional or &key forms of an ordinary lambda list.  See also bug #49.
    ansi-tests: defun.5 defun.6 defun.7

42. &WHOLE causes an error during macroexpansion in destructuring-bind.
    ansi-tests: destructuring-bind.20
    
43. destructuring-bind fails to destructure in the &rest parameter
    ansi-tests: destructuring-bind.21

44. The macro function for destructuring-bind (and, I suspect, many
    other builtin macros) fails to properly signal a program error
    when called on an invalid number of arguments.  ansi-tests:
    destructuring-bind.error.[789]

45..No hash table with :key EQUALP.
    ansi-tests:  equalp.21

46. EQUALP fails to properly compare hash tables.
    ansi-tests: equalp.22 to equalp.35

47. The type error signaled by EVERY and related functions has
    the datum and expected-type slots switched.  ansi-tests:
    every.error.1 notany.error.1  notevery.error.1 some.error.1

48. flet and labels do not accept SETF function names.
    ansi-tests: flet.17 labels.17 flet.51 labels.26

49. Free special declarations in flet and labels forms do not affect
    the expressions in the &aux, &optional and &key fields of the
    ordinary lambda list.  See also bug #41.  ansi-tests: flet.62 flet.63
    flet.67 labels.41 labels.42 labels.46

50. Funcall should throw an undefined function error when called on a symbol
    that has a macro function binding but not a function binding.
    ansi-tests: funcall.error.3

51. function-lambda-expression is not defined.
    ansi-tests: function-lambda-expression.[123]
    function-lambda-expression.order.1 function-lambda-expression.error.[12]

52. Lambda forms are no longer of type function.
    ansi-tests: function.6 function.10 functionp.6 functionp.10

53. Symbols are no longer functions.
    ansi-tests: functionp.2

54. Free special declarations do not apply to the init forms of a LET or LET*.
    ansi-tests: let.17 let.17a let*.17 let*.17a let*.18

55. &whole not recognized in macro lambda list
    anso-tests: macrolet.5 macrolet.36 defmacro.7

56. symbol-macros are not showing up in the macro expansion environment
    ansi-tests: macrolet.13 macrolet.14 

57. :allow-other-keys not being properly handled in macros with &key in
    their macro lambda lists.  ansi-tests: macrolet.32 defmacro.21

58. NIL should match anything in a macro lambda lists.
    ansi-tests: macrolet.39

59, Ordering problem related to presence of symbol macro with side effects
    in multiple-value-setq.  ansi-tests: multiple-value-setq.[58]

60. Free special declarations should not apply to the initialization
    forms in PROG, PROG* forms.  ansi-tests: prog.11 prog*.11

61. DEFINE-COMPILER-MACRO is undefined

62. DEFINE-SYMBOL-MACRO is undefined

63. CONSTANTP should take an optional second argument, an environment
    or nil (and which may be ignored.)  ansi-tests: constantp.6
    constantp.8 constantp.order.2

64. Free special declarations in a LAMBDA form should not affect
    the expressions in key, aux, or optional parameters.
    ansi-tests: lambda.52 lambda.53 lambda.55

65. The second argument to COMPILE is allowed to be a function;
    not just a lambda expression.  ansi-tests: lambda.55 lambda.56

66. COMPILE-FILE is incorrectly executing the code twice i
     an EVAL-WHEN form with both the :COMPILE-TOPLEVEL and
    :LOAD-TOPLEVEL keywords.  ansi-tests: eval-when.1

67. DEFMACRO is not defining the macro function in the lexical
    environment in which the DEFMACRO form appears.
    ansi-tests: defmacro.3 defmacro.4 defmacro.12 defmacro.13

68. (typep nil (find-class 'null)) ==> nil
    ansi-tests: the.9 the.10

69. (VALUES &REST ...) not being understood.
    ansi-tests: the.14 the.15 the.18 the.21 the.22

70. (THE (VALUES ... &OPTIONAL ...) (EVAL '(VALUES ...))) is
    signaling a spurious error.  ansi-tests: the.20 the.23

71. SYMBOL-MACROLET does not admit DECLARE expressions.
    ansi-tests: symbol-macrolet.3 symbol-macrolet.8
    symbol-macrolet.error.1 

72. SYMBOL-MACROLET should signal a program error when
    the symbol is a constant or special variable, but it does not.
    ansi-tests: symbol-macrolet.error.1 symbol-macrolet.error.2

73. MACRO-FUNCTION should take an optional second argument (that
    is an environment or NIL), but it does not.
    ansi-tests: macro-function.[2379] macro-function.1[135]
      loop-finish.error.1

74. SUBTYPEP problems (ansi-tests: types.3)

   a. GENERIC-FUNCTION FUNCTION ==> NIL T
   b. UNBOUND-SLOT CELL-ERROR ==> NIL T
      (see also unbound-slot-cpl)
   c. FLOATING-POINT-INVALID-OPERATION ARITHMETIC-ERROR ==> NIL T
      (see also floating-point-invalid-operation-cpl type-of.5)
   d. FLOATING-POINT-INEXACT ARITHMETIC-ERROR ==> NIL T
      (see also floating-point-inexact-cpl type-of.5)
   e. LOGICAL-PATHNAME PATHNAME ==> NIL T
   f. PRINT-NOT-READABLE ERROR ==> NIL T
      (see also print-not-readable-cpl)
   g. READER-ERROR PARSE-ERROR ==> NIL T
      (see also reader-error-cpl)
   h. READER-ERROR STREAM-ERROR ==> NIL T

   (see also condition.2 for subtype failures on expected subtype
    relationships of condition types)

75. More SUBTYPEP problems (ansi-tests: types.9a)

   a. VECTOR SIMPLE-ARRAY ==> T T
   b. ARRAY SIMPLE-ARRAY ==> T T
   c. BIT-VECTOR SIMPLE-ARRAY ==> T T
   d. BIT-VECTOR SIMPLE-BIT-VECTOR ==> T T

   (counterexample elements were found for all these supposed subtype
    relationship.)

76. (subtypep 'function 'atom) ==> T T (which is correct), but there
    are function objects that are not of type atom.  The problem is that
    cons cells are used to represent functions.  The problem is tbat
    lambda expressions are no longer of type FUNCTION in CLtS.
    (also from ansi-test types.9a, see also
     universe-elements-in-at-most-one-disjoint-type)

77. Yet more SUBTYPEP problems:
     (subtypep 'standard-object (find-class 'standard-object)) ==> nil t
    ansi-tests: all-classes-are-type-equivalent-to-their-names

78. A number of standardized classes are implemented as structure
    classes (which is allowed) but subtypep is not recognizing them
    as subtypes of structure-object:  synonym-stream, hash-table,
    broadcast-stream,  echo-stream, pathname, concatenated-stream,
    readtable, function, file-stream, string-stream, stream, package,
    two-way-stream.
    ansi-tests: all-structure-classes-are-subtypes-of-structure-object

79. The standardized generic function DOCUMENTATION should be a member
    of the class GENERIC-FUNCTION.

80. SUBTYPEP is not correctly determining that if a class X is a subclass
    of classes Y and Z, then X is a subtype of (AND Y Z) (it is allowed
    to fail to determine the subtype relationship, but if it does it must
    determine it correctly).  ansi-tests: tac-3.16

81. (let ((x (make-condition 'arithmetic-error))) (typep x (class-of x)))
      ==> NIL
    ansi-tests: coerce.3 

82. In a DEFTYPE lambda list, the default value for missing key or optional
    parameters should be the symbol *, not NIL.
    ansi-tests: deftype.11 deftype.12 deftype.18

83. SUBTYPEP is not correctly handling a DEFTYPE that yields the NIL type:
     (deftype foo () nil)
     (subtypep '(foo) nil) ==> nil t
    ansi-tests: deftype.13

84. The body of a DEFTYPE form should be in an implicit block whose name
    is the name of the type being defined.
    ansi-tests: deftype.16

85. DEFTYPE forms are not allowing all DECLARE expressions.
    ansi-tests: deftype.19

86. Free special declarations in a DEFTYPE should not apply to the
    forms in optional or key arguments in the deftype lambda list.
    ansi-tests: deftype.15

87. The method parameter specifier (X FUNCTION) is not matching
    the function value #'CONS.
    ansi-tests: standard-generic-function.[12]

88. Numerous problems with TYPE-OF (ansi-tests: type-of.1 type-of.4)

   a. TYPE-OF of a nonnegative integer must be a subtype of UNSIGNED-BYTE.
   b. #\Rubout, #\Tab, #\Backspace, #\Return, and #\Page are BASE-CHARs,
      and have TYPE-OF ==> STRING-CHAR,  but
       (SUBTYPEP 'STRING-CHAR 'BASE-CHAR) ==> nil t
   c. TYPE-OF on condition objects returns PCL::STD-INSTANCE, which is
      not a subtypep of the condition types to which the objects belong.
      It also isn't a subtype of the class returned by CLASS-OF.
   d, TYPE-OF on #(nil nil) is VECTOR, but #(nil nil) is a SIMPLE-VECTOR.
   e. TYPE-OF on a logical pathname returns PATHNAME, which is not a subtype
      of LOGICAL-PATHNAME.
   f. TYPE-OF on standard methods returns PCL::STD-INSTANCE, which is not
      a subtype of METHOD, STANDARD-METHOD, OR STANDARD-OBJECT.
      It is also not a subtype of (CLASS-OF <method>).
   g. TYPE-OF on a compiled closure for a generic function yields
      COMPILED-FUNCTION, which is not a subtype of GENERIC-FUNCTION,
      STANDARD-GENERIC-FUNCTION, or STANDARD-OBJECT.  It is also not
      a subtype of (CLASS-OF <fun>).

  (Note: in f and g, the STANDARD-OBJECT is there because these entities
   are elements of this type in gcl, although this is not required by
   the standard.  Given that they are elements, the subtype relationship
   is required by the standard.)

89. TYPE-OF on an instance of a user-defined standard class is
    PCL::STD-INSTANCE, but it should be the name of the class
    (or the class itself if it has no name).
    ansi-tests: type-of.7 type-of.8 type-of.9 (and type-of.10,
    indirectly)

90. typep should signal an error if the type is a VALUES type.
    ansi-tests: typep.error.4 typep.error.5 typep.error.6

91. typep should signal an error if the type is a compound function
    type.  ansi-tests: typep.error.7

92. The CPL (class precedence list) tests are failing due to a bug
    in PCL that also showed up in SBCL and CMUCL.  The function starts
    returning NIL after a few calls.  ansi-tests: *-CPL

93. READTABLE-CASE is undefined (and its SETF form)
    ansi-tests: read-symbol.1[678] read-symbol.25
     readtable-case.* set-syntax-from-char-trait-*

94. Binding *READ-SUPPRESS* to true doesn't totally suppress reading;
    reading a list still returns a list, as does reading a vector
    or pathname.
    ansi-tests: read-suppress.9 read-suppress.1[01245]
    read-suppress.sharp-quote.[1235678]
    read-suppress.sharp-left-paren.[123456789]
    read-suppress.sharp-left-paren.1[012]
    read-suppress.sharp-p.[1234567]
    read-suppress.sharp-equal.4
    

95. Binding *READ-SUPPRESS* to true causes the reading of complex
    numbers to abort with a type error.
    read-suppress.sharp-c.[123456789] read-suppress.sharp-c.1[12345]

96. In read suppressed mode, #r does not read the full token following
    it, but stops at the # character.  ansi-tests: read-suppress.sharp-r.10

97. In read suppressed mode, ## terms are not read correctly
    ansi-tests: read-suppress.sharp-sharp.[1234]

98. Reading a token starting with a right paren (an invalid character)
    should signal a READER-ERROR, but it does not.
    ansi-tests: read-suppress.error.1 syntax.right-paren-error.1

99. Reading #< should signal a reader error.
    ansi-tests: read-suppress.error.2 set-syntax-from-char.right-paren
     syntax.sharp-less-than.1

100. Setting the syntax of a character to that of #\" doesn't work.
    ansi-tests: set-syntax-from-char.double-quote

101. Initially, for a new dispatching macro character, every following
    character should have the dispatching macro character function that
    signals a read-error.  This is not happening.
    ansi-tests: make-dispatch-macro-character.3

102. #\Backspace is an invalid character in the standard syntax, and
    reading it should signal a reader-error.  This is not happening.
    ansi-tests: syntax.backspace.invalid

103. #\Rubout is an invalid character in the standard syntax, and
    reading it should signal a reader-error.  This is not happening.
    ansi-tests: syntax.rubout.invalid

104. The string "#0()" should read as the simple vector of length 0,
    but it causes an error. ansi-tests: syntax.sharp-left-paren.2

105. Various malformations of #* syntax should lead to reader errors,
    but do not.  ansi-tests: syntax.sharp-asterisk.error.[123]

106. Binding *read-eval* to nil should cause #. to throw a reader
    error, but it does not always.  ansi-tests: syntax.sharp-dot.error.3

107. #C should tolerate whitespace before the left paren.
    ansi-tests: syntax.sharp-c.5

108. #+(:and) #+(:or) #+(:not ...) lead to errors in the reader (which
    is wrong).  The problem seems to be that the feature expression
    is being read in the current package, not the keyword package.
    ansi-tests: syntax.sharp-plus.5 syntax.sharp-plus.7 syntax.sharp-plus.8
     syntax.sharp-plus.12

109. Reading # followed by whitespace[1] should signal a reader-error,
    but it is not (it is signaling a simple-error that is not a reader-error).
    ansi-tests: syntax.sharp-whitespace.1

110. Reading # followed by a right parenthesis should signal a reader-error,
    but it is not (it is signaling a simple-error that is not a reader-error).
    ansi-tests: syntax.sharp-right-paren.1

111. Reading a rational with zero denominator should signal a reader error.
    ansi-tests: syntax.number-token.error.1

112. Tokens containing only dots and not being a single dot in a position
    where a consing dot is expected should cause a reader-error.
    ansi-tests: syntax.dot-error.[1234567]

113. Reading a comma while not in a backquoted form should signal a
     reader-error.  ansi-tests: syntax.comma-error.[12]

114. Free special declarations in DO, DO* forms should not affect the init
     forms.  ansi-tests: do.16 do*.16

115. NIL is a destructuring pattern that matches anything (and binds
     nothing) and should be allowed in for-as-arithmetic clauses.
     ansi-tests: loop.1.5[013456] 

116. A while or until clause in a LOOP should be executed at its location,
     not earlier.  ansi-tests: loop.11.29 loop.11.3[01234]

117. Creating a structure whose name is an uninterned symbol causes the
     class that is created to be unfindable with FIND-CLASS.
     ansi-tests: struct-test-31/1[3457] struct-test-31/15a

118. The -P predicate created for a structure of type (vector t) causes
     an error on the string (string (code-char 0)).
     ansi-tests: struct-test-41/3 struct-test-43/3

119. There should be an initialization argument :format-control for
     simple-errors and simple-warnigns.  ansi-tests: error.[2389]
     error.1[02] cerror.[23] cerror.2a warn.8 warn.10 warn.19

120. Error should take a formatter (not just a format string) as its first
     argument. ansi-tests: error.5 error.1 cerror.4a cerror.5

121. The datum slot of the error signaled by a CHECK-TYPE failure
     is not the value being checked. ansi-tests: check-type.[23567]

122. invoke-debugger is not signaling a program error in safe code
     when called with an incorrect number of arguments.

123. The (<type> <handler>) pairs of HANDLER-BIND should accept
     literal function values as handlers, but uncompiled function
     objects (which are improperly implemented as CONSes) cause
     an error.  ansi-tests: handler-bind.9

     (This is also a problem with function literals occuring
      in other expressions, but there isn't a test for that
      in the eval/compile section of ansi-tests.)

124. HANDLER-BIND is not properly handing off a declined condition
     to a following handler in some cases.  ansi-tests: handler-bind.11

125. HANDLER-BIND is not accepting condition class objects as type
     designators.  ansi-tests: handler-bind.17

126. HANDLER-CASE is not accepting condition class objects as type
     designators.  ansi-tests: handler-case.5

127. HANDLER-CASE did not accept a DECLARE expression (by itself)
     in the body of a handler clause.  ansi-tests: handler-case.28

128. Free special declarations in the handler clauses of a HANDLER-CASE
     are improperly affecting the expressions in &aux variables.
     ansi-tests: handler-case.29

129. (typep <condition object> (find-class 'condition)) ==> NIL
     (typep <condition object> (find-class '<its condition class name>)) ==> NIL
     ansi-tests: condition-1/is-a-member-of-class/condition and
      about 30 similar tests

130. compute-restarts is returning a restarts that are not associated with
     the condition being tested.  ansi-tests: compute-restarts.9

131. restart-case with macro, symbols forms not not properly handled:
     ansi-tests: restart-case.29 restart-case.30 restart-case.31

132. Free special declarations in restart definitions in restart-case
     do not have the correct scope.  ansi-tests: restart-case.36

133. continue, store-value, and use-value functions are invoking restarts
     that are applicable to other conditions than the argument condition.
     (Or, with-condition-restarts may not be behaving properly)
     ansi-tests: continue.2 store-value.2 use-value.2

134. A safe call (make-condition) should signal a program error.
     ansi-tests: make-condition.error.1

135. Division by zero should be signaling a divide-by-zero condition,
     not a generic simple error.  ansi-tests /.error.[2345678]

136. (/ -1) is returning three values, not just one.
     ansi-tests: /.2

137. (expt -1 0.0) should be 1.0 (of the appropriate floating type),
     but the result being returned is #c(1.0 0.0).
     ansi-tests: expt.18 expt.19 expt.20 expt.21

138. (lcm) should yield 1, not an error.
     ansi-tests: lcm.1

139. (typep 1 '(real (0))) ==> error  (and similarly for
        (typep 1 '(integer (0))).)
     ansi-tests: random.error.3

140. (phase 0) ==> error (logarithmic singularity)
     ansi-tests: phase.1

141. (float x) should eql x when x is a float, but short-floats
     are being converted to single-floats
     (eql (float 1.0s0) 1.0s0) ==> NIL
     ansi-tests: float.5

142. rational and rationalize should signal type errors on arguments
     that are not of type real in safe code.
     ansi-tests: rational.error.4 rationalize.error.4

143. Apparent compiler problem in this function:

     (defun digit-char.1.body.old ()
       (loop for r from 2 to 36 always
            (loop for i from 0 to 36
               always (let* ((c (digit-char i r))
                             (result
                              (if (>= i r) (null c)
                                  (eqlt c (char +extended-digit-chars+ i)))))
                        (unless result
                          (format t "~A ~A ~A~%" r i c))
                        result))))

      When called, it prints  2 2 p and returns nil.  However,
      (digit-char 2 2) ==> nil when called at the REPL.

      (this is from digit-char.1, but that test has been changed.)

144. digit-char should take at most two arguments, but it is failing
     to signal a program error in safe code when given more.
     ansi-tests: digit-char.error.2

145. standard-char-p should signal a type error in safe code when
     called on a non-character.  ansi-tests: standard-char-p.3

146. code-char should signal an error in safe code when called with
     more than one argument.  ansi-tests: code-char.error.2

147. adjust-array does not have the correct semantics when performed
     on the middle of a chain of three displaced bit vectors.  The chain
     appears to have been improperly short-circuited.
     ansi-tests: adjust-array.bit-vector.adjustable.13

148. fill-pointer should signal a type error when called with vectors
     that lack fill pointers.  It does, but the expected-type field
     is wrong.  ansi-tests: fill-pointer.error.[36]

149. The value (upgraded-array-element-type 'base-char) should be
     type-equivalent to base-char.  However, it is string-char,
     and (subtypep 'string-char 'base-char) ==> nil t
     ansi-tests: upgraded-array-element-type.2

150. upgraded-array-element-type violates the 'preserves subtype'
     properties for numerous types.  For example:

      (upgraded-array-element-type '(eql 2)) ==> lisp:signed-char
      but
      (upgraded-array-element-type '(unsigned-byte 16)) ==>
             lisp:unsigned-short

     ansi-tests: upgraded-array-element-type.8

151. (upgraded-array-element-type nil) ==> t, but it should be nil.

152. vector-pop should signal a type-error when passed a vector
     that lacks a fill pointer.  It does, but the expected-type
     slot is wrong.  ansi-tests: vector-pop.error.[15]

153. (make-hash-table :size 0) signals an error, but 0 is a legal
     value for the size parameter.  ansi-tests: make-hash-table.2

154. equalp hash tables are not supported.
     ansi-tests: make-hash-table.1[01] hash-table-count.[59]
     hash-table-rehash-threshold.[23] hash-table-test.[234]
     gethash.zero.4 remhash.4 clrhash.4 maphash.[36]
     with-hash-table-iterator.7
 
155. (make-hash-table :rehash-threshold x) errors:

    a. x == 0 (or 0.0s0, or 0.0)  signals an error, but zero
     is a legal value for this parameter.  ansi-tests:
     make-hash-table.1[6789] make-hash-table.20
     
    b. x == 1/2 signals an error, but this is a legal value for
     this parameter.  ansi-tests: make-hash-table.21

156. The third argument to GETHASH in the SETF form should be
    allowed, but instead is causing an error.
    ansi-tests: gethash.5 gethash.order.4

157. The last invocation of the local macro in WITH-HASH-TABLE-ITERATOR
    should return just a single value, NIL, but it is returning
    three values.  ansi-tests: with-hash-table-iterator.4

158. PATHNAME, when called on a stream, should return the pathname
    that was used to create the stream.  However, for logical pathnames,
    this is not happening -- the physical pathname corresponding to the
    logical pathname is returned instead.
    ansi-tests: logical-pathname.3

159. ensure-directories-exist should signal a file-error if part of
    the directory is wild, but it does not.
    ansi-tests: ensure-directories-exist.error.1

160. stream-element-type is returning :default on a stream opened
    with OPEN.  This violates the constraint that this type must
    be a subtype of integer or character.  ansi-tests: stream-element-type.6

161. Cannot write (1- (ash 1 32)) to a stream with :element-type
    (unsigned-byte 32) using write-byte. ansi-tests: read-byte.3
     read-byte.4 file-length.[2345]

162. peek-char advances the file position of echo streams.
     ansi-tests: peek-char.17

163  Passing NIL to the :start argument of read-sequence or write-sequence
     is treated as if the parameter were not present.  This is incorrect:
     :start, if provided, must be a nonnegative integer, and should signal
     a type error in safe calls otherwise..  ansi-tests:
     read-sequence.error.9 write-sequence.error.15

164. file-string-length is computing the wrong thing.  It should compute
     the change in file position after an object is printed as a sequence
     of characters, not as printed in readable representation.  #\a, for
     example, should occupy one position, not three.
     ansi-tests: file-string-length.[12]

165. Free declarations in with-open-file forms should not have the return
     value form in their scope.  ansi-tests: with-open-file.[789]

166. open-stream-p reports that a string-stream (input or output)
     is still open, even after it has been closed.  ansi-tests:
     with-open-stream.[6789]

167. Free declarations in a with-open-stream form are incorrectly
     being applied to the return value form.  ansi-tests: with-open-stream.10

168. (typep (make-broadcast-stream) 'broadcast-stream) ==> nil (and related).
     ansi-tests: make-broadcast-stream.[123]

169. file-position should return 0 on null broadcast streams.
     ansi-tests: make-broadcast-stream.6

170. file-string-length should return 1 on null broadcast streams.
     ansi-tests: make-broadcast-stream.7

171. make-broadcast-stream should signal a type error in safe calls
     when an argument is not an output stream.
     ansi-tests: make-broadcast-stream.error.[12]

