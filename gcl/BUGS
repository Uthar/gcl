This is a list of bugs that have been found in gcl.  When you fix
a bug, add the notation (FIXED) after the bug number, but leave the
number in place so it isn't reused.

1 (FIXED). (subtypep s 'structure-object) isn't working properly when
  s is a structure class name or a structure class object.
  This is causing 95 ansi-test failures.

2. (sublis x y :test #'fn) is passing the arguments to fn in the
  wrong order.  The problem here is that the :key argument is being
  applied somewhat unusually, making the usual TEST macro not do
  quite the right thing.  ansi-tests: sublis.9 and sublis.10

3. (nsublis x y :test #'fn) is passing the arguments to fn in the
  wrong order. Similar to bug #2.  ansi-tests:  nsublis.10 and nsublis.11

4. (last x n) is incorrectly signaling an error when n is a positive
  bignum.  Instead, it should return x.   ansi-tests: last.11, last.12

5. The map* functions should signal a type error when given an improper
  list.  They do so, but the slots of the type error object don't
  satisfy the property that the value in the datum slot is not of
  the type in the expected-type slot.  ansi-tests: mapc.error.8,
  mapcar.error.8, mapcan.error.8, mapl.error.8, maplist.error.11,
  mapcon.error.8

6. Similar to #5, but the error is for GET-PROPERTIES.  ansi-tests:
   get-properties.error.[456]

7. (SETF (GETF form1 form2 form3) form4) is evaluating the subforms
  in the wrong order: form3 is being evaluated before (the subforms of)
  form1 and form2.  ansi-tests: setf-getf.order.2

8. Similar to #5, but the error is for GETF.  ansi-tests: getf.error.[45]

9. REMF is violating the requirement that the value of the place be
  read out after all the other subforms of the REMF form are computed
  (even the ones to the right of the place form; see section 5.1.3
  of CLtS).  ansi-tests:  remf.order.3

10. Similar to #5, but on ELT when the index is out of range.  Should
  return a type-error with datum == the index and type ==
  `(integer 0 (,(length sequence))) (or NIL if the sequence has length 0).
  ani-tests:  elt.1, elt.1b, elt.2, 

11. There's an internal type error somewhere in the code exercised by
  elt.10 -- the invalid type (integer 0 . 1) is being passed to TYPEP
  (and similarly for elt.14, elt-v.1, elt-v.10, elt-adj-array.1,
   elt-adj-array.10, elt-displaced-array.1, elt-fill-pointer.[3468],
   and elt,error.[45]).

12. Coerce can't coerce a vector of characters into a base-string.
  ansi-tests: fill.string.10

13. MAKE-SEQUENCE fails on type argument NULL,. (CLASS-OF NIL), or LIST.
   ansi-tests: make-sequence,9, make-sequence.49. make-sequence.57

14. The datum and expected type fields of the type errors thrown by
   MAKE-SEQUENCE, MAP  do not satisfy the constraint that the datum
   is not of type expected-type.  ansi-tests: make-sequence.error.1,
   make-sequence.error.2, make-sequence.error.14, make-sequence.error.16,
   map.error.1, map.error.1a, map.error.11.

15. MAP fails on type argument NULL, (OR (VECTOR 5) (VECTOR 10))
   ansi-tests: map-null.1, map.48

16. NREVERSE is broken on vectors of element type LISP:SIGNED-SHORT

    (let ((v (make-array '(7) :initial-contents '(1 1 0 1 1 1 0)
                  :element-type 'lisp:signed-short)))
      (nreverse v))
    ==> #(0 1 1 1 1 1 0)

   (ansi-tests: nreverse-vector.7, nreverse-vector.8)

17. The setf expander for SUBSEQ returns the wrong value (the entire
   vector is returned rather than the aubsequence being assigned.)
   ansi-tests: subseq.order.[34]

18. CONCATENATE fails on type argument of NULL, as does MERGE.
   ansi-tests:. concatenate.24, merge-null.1, merge.error.6

19, There are 140 symbols exported from the COMMON-LISP package that
   should not be external in taht package.
   ansi-tests: no-extra-symbols-exported-from-common-lisp
    all-exported-cl-class-names-are-valid

20. 19 functions are missing: arithmetic-error-operands
  broadcast-stream-streams cell-error-name concatenated-stream-streams
  echo-stream-input-stream echo-stream-output-stream
  function-lambda-expression get-setf-expansion
  make-load-form-saving-slots pprint-indent pprint-newline
  pprint-tab print-not-readable-object simple-condition-format-control
  synonym-stream-symbol two-way-stream-input-stream
  two-way-stream-output-stream unbound-slot-instance
  compiler-macro-function readtable-case.

  ansi-tests: cl-function-symbols.1, dcf-funs and these tests:

   cell-error-name:
      symbol-value.error.5 symbol-function.error.5 makunbound.2
      eval.error.3 eval.error.4 
   get-setf-expansion
      get-setf-expansion.error.[12] get-setf-expansion.[123]

21. The following macros are missing: define-compiler-macro
    define-setf-expander define-symbol-macro in-package.
    ansi-tests: cl-macro-symbols.1 in-package.error.1
    dcf-macros define-setf-expander.error.1
    define-setf-expander.[1234567] define-compiler-macro.error.[123]
    define-compiler-macro.[12345678] define-symbol-macro.error.[123]

22. GENTEMP should take a package designator as its second argument,
   not just a package object. ansi-tests: gentemp.[345].

23. (special-operator-p 'symbol-macrolet) should be true.
   ansi-tests: special-operator-p.1

24. (debatable) special-operator-p should be nil on DECLARE and IN-PACKAGE.
   ansi-tests: special-operator-p.2

25. (debatable) "USER" should not be a nickname of "COMMON-LISP-USER"
     (instead, it can name a separate package).
    ansi-tests: common-lisp-user-package-nicknames

26. FIND-ALL-SYMBOLS should take a string designator, which includes
    character values.  ansi-tests: find-all-symbols.2

27. Free special declarations do not apply to the final value clauses
    of iteration forms.  ansi-tests: do-symbols.16 do-external-symbols.16

28. The scope of the bound variable in DO-ALL-SYMBOLS should include
    the final value form.  ansi-tests: do-all-symbols.4

29. The implicit block in DO-ALL-SYMBOLS should surround the entire
    loop, including the return value form.  ansi-tests: do-all-symbols.6

30. DO-ALL-SYMBOLS should accept declarations. ansi-tests: do-all-symbols.9
    do-all-symbols.10 do-all-symbols.11

31. IMPORT should set the home package of any symbol being imported that
    does not have a home package.  ansi-tests: import.5

32. The setf expander for VALUES evaluates the source form before the subforms
    of the destination places.  ansi-tests: setf-values.5

33. Order of evaluation problem in expansion of psetq/psetf, possibly involving
    symbol macros.  ansi-tests: psetq.7 psetf.7

34. Cannot create classes whose names are uninterned symbols.
    ansi-tests: psetf.35 rotatef.35

35. ROTATEF does not work with no arguments.  snsi-tests: rotatef.3

36. DEFSETF (long form) should produce an implicit block with the name
    of the accessor-fn.  ansi-tests: defsetf.5a

37. The expansion function produced by DEFSETF (long form) should be defined
    in the same lexical environment in which the DEFSETF form appears.
    ansi-tests: defsetf.6a

38. The control error signaled by (throw (gensym) nil) isn't printable
    when *print-escape* and *print-readably* are nil. ansi-tests: throw-error

39. DOCUMENTATION should be allowed to be called on function objects, not
    just function names. ansi-tests: define-modify-macro.documentation.1
    define-modify-macro.documentation.2

40. In DEFUN where the function names is a (SETF <name>) pair, there is an
    implicit block with name <name>.  ansi-tests: defun.4

41. Free special declarations do not apply to the expressions in &aux,
    &optional or &key forms of an ordinary lambda list.  See also bug #49.
    ansi-tests: defun.5 defun.6 defun.7

42. &WHOLE causes an error during macroexpansion in destructuring-bind.
    ansi-tests: destructuring-bind.20
    
43. destructuring-bind fails to destructure in the &rest parameter
    ansi-tests: destructuring-bind.21

44. The macro function for destructuring-bind (and, I suspect, many
    other builtin macros) fails to properly signal a program error
    when called on an invalid number of arguments.  ansi-tests:
    destructuring-bind.error.[789]

45 .No hash table with :key EQUALP.
    ansi-tests:  equalp.21

46. EQUALP fails to properly compare hash tables.
    ansi-tests: equalp.22 to equalp.35

47. The type error signaled by EVERY and related functions has
    the datum and expected-type slots switched.  ansi-tests:
    every.error.1 notany.error.1  notevery.error.1 some.error.1

48. flet and labels do not accept SETF function names.
    ansi-tests: flet.17 labels.17 flet.51 labels.26

49. Free special declarations in flet and labels forms do not affect
    the expressions in the &aux, &optional and &key fields of the
    ordinary lambda list.  See also bug #41.  ansi-tests: flet.62 flet.63
    flet.67 labels.41 labels.42 labels.46

50. Funcall should throw an undefined function error when called on a symbol
    that has a macro function binding but not a function binding.
    ansi-tests: funcall.error.3

51. function-lambda-expression is not defined.
    ansi-tests: function-lambda-expression.[123]
    function-lambda-expression.order.1 function-lambda-expression.error.[12]

52. Lambda forms are no longer of type function.
    ansi-tests: function.6 function.10 functionp.6 functionp.10

53. Symbols are no longer functions.
    ansi-tests: functionp.2

54. Free special declarations do not apply to the init forms of a LET or LET*.
    ansi-tests: let.17 let.17a let*.17 let*.17a let*.18

55. &whole not recognized in macro lambda list
    anso-tests: macrolet.5 macrolet.36 defmacro.7

56. symbol-macros are not showing up in the macro expansion environment
    ansi-tests: macrolet.13 macrolet.14 

57. :allow-other-keys not being properly handled in macros with &key in
    their macro lambda lists.  ansi-tests: macrolet.32 defmacro.21

58. NIL should match anything in a macro lambda lists.
    ansi-tests: macrolet.39

59, Ordering problem related to presence of symbol macro with side effects
    in multiple-value-setq.  ansi-tests: multiple-value-setq.[58]

60. Free special declarations should not apply to the initialization
    forms in PROG, PROG* forms.  ansi-tests: prog.11 prog*.11

61. DEFINE-COMPILER-MACRO is undefined

62. DEFINE-SYMBOL-MACRO is undefined

63. CONSTANTP should take an optional second argument, an environment
    or nil (and which may be ignored.)  ansi-tests: constantp.6
    constantp.8 constantp.order.2

64. Free special declarations in a LAMBDA form should not affect
    the expressions in key, aux, or optional parameters.
    ansi-tests: lambda.52 lambda.53 lambda.55

65. The second argument to COMPILE is allowed to be a function;
    not just a lambda expression.  ansi-tests: lambda.55 lambda.56

66. COMPILE-FILE is incorrectly executing the code twice i
     an EVAL-WHEN form with both the :COMPILE-TOPLEVEL and
    :LOAD-TOPLEVEL keywords.  ansi-tests: eval-when.1

67. DEFMACRO is not defining the macro function in the lexical
    environment in which the DEFMACRO form appears.
    ansi-tests: defmacro.3 defmacro.4 defmacro.12 defmacro.13

68. (typep nil (find-class 'null)) ==> nil
    ansi-tests: the.9 the.10

69. (VALUES &REST ...) not being understood.
    ansi-tests: the.14 the.15 the.18 the.21 the.22

70. (THE (VALUES ... &OPTIONAL ...) (EVAL '(VALUES ...))) is
    signaling a spurious error.  ansi-tests: the.20 the.23

71. SYMBOL-MACROLET does not admit DECLARE expressions.
    ansi-tests: symbol-macrolet.3 symbol-macrolet.8
    symbol-macrolet.error.1 

72. SYMBOL-MACROLET should signal a program error when
    the symbol is a constant or special variable, but it does not.
    ansi-tests: symbol-macrolet.error.1 symbol-macrolet.error.2

73. MACRO-FUNCTION should take an optional second argument (that
    is an environment or NIL), but it does not.
    ansi-tests: macro-function.[2379] macro-function.1[135]

74. SUBTYPEP problems (ansi-tests: types.3)

   a. GENERIC-FUNCTION FUNCTION ==> NIL T
   b. UNBOUND-SLOT CELL-ERROR ==> NIL T
      (see also unbound-slot-cpl)
   c. FLOATING-POINT-INVALID-OPERATION ARITHMETIC-ERROR ==> NIL T
      (see also floating-point-invalid-operation-cpl type-of.5)
   d. FLOATING-POINT-INEXACT ARITHMETIC-ERROR ==> NIL T
      (see also floating-point-inexact-cpl type-of.5)
   e. LOGICAL-PATHNAME PATHNAME ==> NIL T
   f. PRINT-NOT-READABLE ERROR ==> NIL T
      (see also print-not-readable-cpl)
   g. READER-ERROR PARSE-ERROR ==> NIL T
      (see also reader-error-cpl)
   h. READER-ERROR STREAM-ERROR ==> NIL T

75. More SUBTYPEP problems (ansi-tests: types.9a)

   a. VECTOR SIMPLE-ARRAY ==> T T
   b. ARRAY SIMPLE-ARRAY ==> T T
   c. BIT-VECTOR SIMPLE-ARRAY ==> T T
   d. BIT-VECTOR SIMPLE-BIT-VECTOR ==> T T

   (counterexample elements were found for all these supposed subtype
    relationship.)

76. (subtypep 'function 'atom) ==> T T (which is correct), but there
    are function objects that are not of type atom.  The problem is that
    cons cells are used to represent functions.  The problem is tbat
    lambda expressions are no longer of type FUNCTION in CLtS.
    (also from ansi-test types.9a, see also
     universe-elements-in-at-most-one-disjoint-type)

77. Yet more SUBTYPEP problems:
     (subtypep 'standard-object (find-class 'standard-object)) ==> nil t
    ansi-tests: all-classes-are-type-equivalent-to-their-names

78. A number of standardized classes are implemented as structure
    classes (which is allowed) but subtypep is not recognizing them
    as subtypes of structure-object:  synonym-stream, hash-table,
    broadcast-stream,  echo-stream, pathname, concatenated-stream,
    readtable, function, file-stream, string-stream, stream, package,
    two-way-stream.
    ansi-tests: all-structure-classes-are-subtypes-of-structure-object

79. The standardized generic function DOCUMENTATION should be a member
    of the class GENERIC-FUNCTION.

80. SUBTYPEP is not correctly determining that if a class X is a subclass
    of classes Y and Z, then X is a subtype of (AND Y Z) (it is allowed
    to fail to determine the subtype relationship, but if it does it must
    determine it correctly).  ansi-tests: tac-3.16

81. (let ((x (make-condition 'arithmetic-error))) (typep x (class-of x)))
      ==> NIL
    ansi-tests: coerce.3 

82. In a DEFTYPE lambda list, the default value for missing key or optional
    parameters should be the symbol *, not NIL.
    ansi-tests: deftype.11 deftype.12 deftype.18

83. SUBTYPEP is not correctly handling a DEFTYPE that yields the NIL type:
     (deftype foo () nil)
     (subtypep '(foo) nil) ==> nil t
    ansi-tests: deftype.13

84. The body of a DEFTYPE form should be in an implicit block whose name
    is the name of the type being defined.
    ansi-tests: deftype.16

85. DEFTYPE forms are not allowing all DECLARE expressions.
    ansi-tests: deftype.19

86. Free special declarations in a DEFTYPE should not apply to the
    forms in optional or key arguments in the deftype lambda list.
    ansi-tests: deftype.15

87. The method parameter specifier (X FUNCTION) is not matching
    the function value #'CONS.
    ansi-tests: standard-generic-function.[12]

88. Numerous problems with TYPE-OF (ansi-tests: type-of.1 type-of.4))

   a. TYPE-OF of a nonnegative integer must be a subtype of UNSIGNED-BYTE.
   b. #\Rubout, #\Tab, #\Backspace, #\Return, and #\Page are BASE-CHARs,
      and have TYPE-OF ==> STRING-CHAR,  but
       (SUBTYPEP 'STRING-CHAR 'BASE-CHAR) ==> nil t
   c. TYPE-OF on condition objects returns PCL::STD-INSTANCE, which is
      not a subtypep of the condition types to which the objects belong.
      It also isn't a subtype of the class returned by CLASS-OF.
   d, TYPE-OF on #(nil nil) is VECTOR, but #(nil nil) is a SIMPLE-VECTOR.
   e. TYPE-OF on a logical pathname returns PATHNAME, which is not a subtype
      of LOGICAL-PATHNAME.
   f. TYPE-OF on standard methods returns PCL::STD-INSTANCE, which is not
      a subtype of METHOD, STANDARD-METHOD, OR STANDARD-OBJECT.
      It is also not a subtype of (CLASS-OF <method>).
   g. TYPE-OF on a compiled closure for a generic function yields
      COMPILED-FUNCTION, which is not a subtype of GENERIC-FUNCTION,
      STANDARD-GENERIC-FUNCTION, or STANDARD-OBJECT.  It is also not
      a subtype of (CLASS-OF <fun>).

  (Note: in f and g, the STANDARD-OBJECT is there because these entities
   are elements of this type in gcl, although this is not required by
   the standard.  Given that they are elements, the subtype relationship
   is required by the standard.)

89. TYPE-OF on an instance of a user-defined standard class is
    PCL::STD-INSTANCE, but it should be the name of the class
    (or the class itself if it has no name).
    ansi-tests: type-of.7 type-of.8 type-of.9 (and type-of.10,
    indirectly)

90. typep should signal an error if the type is a VALUES type.
    ansi-tests: typep.error.4 typep.error.5 typep.error.6

91. typep should signal an error if the type is a compound function
    type.  ansi-tests: typep.error.7
