(in-package :si)

(defun make-hash-table (&key (test 'eql) (size 1024) (rehash-size 1.5s0) (rehash-threshold 0.7s0))
  (the hash-table (make-hash-table-int test size rehash-size rehash-threshold)))

(defun hash-table-p (x)
  (declare (optimize (safety 1)))
  (typecase x (hash-table t)))

(defun gethash (x y &optional z)
  (declare (optimize (safety 1)))
  (check-type y hash-table)
  (let ((e (gethash-int x y)))
    (if (eq (cdr e) (nani 0)) (values z nil) (values (car e) t))))

(defun maphash (f h)
  (declare (optimize (safety 1)))
  (check-type h hash-table)
  (let ((n (hash-table-size h)))
    (dotimes (i n)
      (let* ((e (hashtable-self h i))
	     (k (cdr e)))
	(unless (eq k (nani 0))
	  (funcall f k (car e)))))))

(defun remhash (x y)
  (declare (optimize (safety 1)))
  (check-type y hash-table)
  (let ((e (gethash-int x y)))
    (unless (eq (cdr e) (nani 0))
      (rplacd e (nani 0))
      (rplaca e nil)
      (c-set-hashtable-nent y (1- (c-hashtable-nent y)))
      t)))

(defun clrhash (h)
  (declare (optimize (safety 1)))
  (check-type h hash-table)
  (let ((n (hash-table-size h)))
    (dotimes (i n)
      (let ((e (hashtable-self h i)))
	(rplacd e (nani 0))
	(rplaca e (nani 0))))
    (c-set-hashtable-nent h 0)
    h))

(defun sxhash (x)
  (declare (optimize (safety 1)))
  (typecase x
	    (symbol (c-symbol-hash x))
	    (otherwise (hash-equal x 0))))

(setf (symbol-function 'hash-table-count) (symbol-function 'c-hashtable-nent))
(setf (symbol-function 'hash-table-size)  (symbol-function 'c-hashtable-size))

