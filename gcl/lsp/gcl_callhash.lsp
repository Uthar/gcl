;; -*-Lisp-*-
(in-package 'si)

(*make-special '*pahl*)
(*make-special '*boot*)
(eval-when (load eval)
	   (setq *pahl* nil)
	   (setq *boot* nil))

(export '(function-lambda-expression))

(defun add-hash (fn sig callees src)
  (cond ((not (eq *boot* t))
	 (setq *pahl* (cons `(add-hash ',fn ',sig ',callees ,src) *pahl*))
	 (unless (or (not (fboundp 'make-s-data)) (not (let ((s (find-symbol "FIND"))) (and s (fboundp s)))) *boot*)
	   (setq *boot* 'add-hash) 
	   (let ((*package* (find-package "SI")))
	     (defstruct (call (:copier copy-call)
			      (:predicate call-p)
			      (:constructor make-call))
			      sig callees callers src)
	     (defvar *call-hash-table* (make-hash-table :test 'eq))
	     (defvar *needs-recompile* (make-array 10 :fill-pointer 0 :adjustable t))
	     (defvar *ach* (make-hash-table :test 'eq))
	     (setq *boot* t)
	     (mapc 'eval (nreverse *pahl*))
	     (setq *pahl* nil))))
	((let ((h (or (gethash fn *call-hash-table*)
		      (setf (gethash fn *call-hash-table*) (make-call :sig sig)))))
	   (when sig (proclaim `(ftype (function ,@sig) ,fn)))
	   (when (and sig (not (equal sig (call-sig h))))
	     (dolist (l (call-callers h))
	       (unless (eq l fn)
		 (add-recompile l fn (call-sig h) sig)))
	     (setf (call-sig h) sig))
	   (when src (setf (call-src h) src))
	   (let (ar)
	     (dolist (l callees (unless ar (when sig (remove-recompile fn))))
	       (pushnew (car l) (call-callees h))
	       (let ((h (or (gethash (car l) *call-hash-table*)
			    (setf (gethash (car l) *call-hash-table*) (make-call :sig (cdr l) :callers (list fn))))))
		 (pushnew fn (call-callers h))
		 (unless (or (eq fn (car l)) (equal (cdr l) (call-sig h)))
		   (add-recompile fn (car l) (cdr l) (call-sig h))
		   (setq ar t)))))))))

(defun clear-compiler-properties (sym code)
  (cond ((not (eq *boot* t))
	 (push `(clear-compiler-properties ',sym nil) *pahl*))
	((let ((h (or (gethash sym *call-hash-table*) 
		      (setf (gethash sym *call-hash-table*) (make-call)))))
	   (dolist (l (call-callees h))
	     (let ((l (gethash l *call-hash-table*)))
	       (setf (call-callers l) (delete sym (call-callers l)))))
	   (let (new)
	     (maphash (lambda (x y) 
			(when (and (fboundp x) (eq (symbol-function x) code) (call-src y))
			  (setq new x))) *call-hash-table*)
	     (cond (new
		    (let ((nr (find new *needs-recompile* :key 'car)))
		      (when nr (add-recompile sym (cadr nr) (caddr nr) (cadddr nr))))
		    (setq new (gethash new *call-hash-table*))
		    (let ((ns (call-sig new)))
		      (unless (equal ns (call-sig h))
			(dolist (l (call-callers h))
			  (add-recompile l sym (call-sig h) ns)))
		      (setf (call-sig h) ns)
		      (proclaim `(ftype (function ,@ns) ,sym)))
		    (dolist (l (call-callees new)) 
		      (pushnew sym (call-callers (gethash l *call-hash-table*))))
		    (setf (call-callees h) (call-callees new) (call-src h) (call-src new)))
		   ((setf (call-callees h) nil (call-src h) nil))))))))

(defun add-recompile (fn why assumed-sig actual-sig)(when (and (eq (symbol-package why) (find-package "COMPILER")) (equal (symbol-name why) "VAR-KIND")) (break "~s ~s ~s ~s~%" fn why assumed-sig actual-sig))
  (unless (find fn *needs-recompile* :key 'car)
;    (format t "add-recompile ~s ~s ~s ~s~%" fn why assumed-sig actual-sig)
    (vector-push-extend (list fn why assumed-sig actual-sig) *needs-recompile*)
    nil))

(defun remove-recompile (fn)
  (let ((p (position fn *needs-recompile* :key 'car)))
    (when p
;      (format t "removing recompile of ~s~%" fn)
      (decf (fill-pointer *needs-recompile*))
      (do ((i p (1+ i))) ((= i (length *needs-recompile*)))
	(setf (aref *needs-recompile* i) (aref *needs-recompile* (1+ i)))))))

(defun clr-call nil 
  (clrhash *call-hash-table*)
  (setf (fill-pointer *needs-recompile*) 0))


(defun all-callees (x y)
  (let ((z (gethash x *ach*)))
    (if z (union z y)
      (let ((z (call-callees (gethash x *call-hash-table*))))
	(do ((l (set-difference z y) (cdr l))
	     (r (union z y) (all-callees (car l) r)))
	    ((endp l) 
	     (unless (intersection z y) (setf (gethash x *ach*) (set-difference r y)))
	     r))))))

;      (let* ((z (call-callees (gethash x *call-hash-table*))) 
;	     (r (union z y))
;	     (q (dolist (l (set-difference z y) r)
;		  (setq r (all-callees l r)))))
;	(unless (intersection z y) (setf (gethash x *ach*) (set-difference q y)))
;	q))))

(defun function-lambda-expression (x) 
  (if (typep x 'interpreted-function) 
      (let* ((x (si::interpreted-function-lambda x)))
	(case (car x)
	      (lambda (values x nil nil))
	      (lambda-block (values (cons 'lambda (cddr x))  nil (cadr x)))
	      (lambda-closure (values (cons 'lambda (cddr (cddr x)))  (not (not (cadr x)))  nil))
	      (lambda-block-closure (values (cons 'lambda (cdr (cddr (cddr x))))  (not (not (cadr x))) (fifth x)))
	      (otherwise (values nil t nil))))
    (values nil t nil)))

(defun function-src (sym)
  (or
   (let* ((h (gethash sym *call-hash-table*))
	  (fas (when h (call-src h))))
     (when fas
       (let* ((ss (open-fasd (make-string-input-stream fas) :input 'eof nil))
	      (out (read-fasd-top ss)))
	 (close-fasd ss)
	 out)))
   (and (fboundp sym) (typep (symbol-function sym) 'interpreted-function) (function-lambda-expression (symbol-function sym)))))

(defun do-recompile (&optional (pn "/tmp/recompile.lsp" pnp))
  (unless (or *disable-recompile* (= 0 (length *needs-recompile*)))
    (let ((*disable-recompile* t))
      (clrhash *ach*)
      (setq *needs-recompile* 
	    (sort *needs-recompile* ;FIXME
		  (lambda (x y) 
		    (member (car x) (all-callees (car y) nil)))))
      (maphash (lambda (x y) (when (call-sig y) (proclaim `(ftype (function ,@(call-sig y)) ,x)))) *call-hash-table*)
      (unless pnp (when (probe-file pn) (delete-file pn)))
      (map nil (lambda (fn)
		 (format t "Callee ~s sigchange ~s to ~s, recompiling ~s~%" 
			 (cadr fn) (caddr fn) (cadddr fn) (car fn))) *needs-recompile*)
       (with-open-file
	(s pn :direction :output :if-exists :append :if-does-not-exist :create)
	(let ((*print-radix* nil)
	      (*print-base* 10)
	      (*print-circle* t)
	      (*print-pretty* nil)
	      (*print-level* nil)
	      (*print-length* nil)
	      (*print-case* :downcase)
	      (*print-gensym* t)
	      (*print-array* t)
	      (si::*print-package* t)
	      (si::*print-structure* t))
	  (dotimes (i (length *needs-recompile*))
	    (let* ((fn (car (aref *needs-recompile* i)))
		   (src (function-src fn)))
	      (if src (prin1 `(defun ,fn ,@(cdr src)) s)
		(remove-recompile fn))))))
      (load (compile-file pn :system-p t :c-file t :h-file t :data-file t)))
    (do-recompile pn)))

;FIXME!!!
(defun is-eq-test-item-list (&rest r)
  (format t "Should never be called ~s~%" r))

(defun cmp-vec-length (x)
  (declare (vector x))
  (if (array-has-fill-pointer-p x) (fill-pointer x) (array-dimension x 0)))

