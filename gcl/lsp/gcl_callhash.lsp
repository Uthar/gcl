;; -*-Lisp-*-
(in-package 'si)

(*make-special '*pahl*)
(*make-special '*boot*)
(*make-special '*tmp-dir*)
(eval-when (load eval)
	   (setq *pahl* nil)
	   (setq *boot* nil))

(export '(function-lambda-expression))

(defun add-hash (fn sig callees src)
  (cond ((not (eq *boot* t))
	 (setq *pahl* (cons `(add-hash ',fn ',sig ',callees ,src) *pahl*))
	 (unless (or (not (fboundp 'make-s-data)) (not (let ((s (find-symbol "FIND"))) (and s (fboundp s)))) *boot*)
	   (setq *boot* 'add-hash) 
	   (let ((*package* (find-package "SI")))
	     (defstruct (call (:copier copy-call)
			      (:predicate call-p)
			      (:constructor make-call))
			      sig callees callers src)
	     (defvar *call-hash-table* (make-hash-table :test 'eq))
	     (defvar *needs-recompile* (make-array 10 :fill-pointer 0 :adjustable t))
	     (defvar *ach* (make-hash-table :test 'eq))
	     (defvar *acr* (make-hash-table :test 'eq))
	     (setq *tmp-dir* (get-temp-dir))
	     (setq *boot* t)
	     (mapc 'eval (nreverse *pahl*))
	     (setq *pahl* nil))))
	((let ((h (or (gethash fn *call-hash-table*)
		      (setf (gethash fn *call-hash-table*) (make-call :sig sig)))))
	   (when sig 
	     (unless (eq (cadr sig) '*) (putprop fn t 'proclaimed-function))
	     (putprop fn (car sig) 'proclaimed-arg-types)
	     (putprop fn (cadr sig) 'proclaimed-return-type))
;	     (proclaim `(ftype (function ,@sig) ,fn)))
	   (when (and sig (not (equal sig (call-sig h))))
	     (dolist (l (call-callers h))
	       (unless (eq l fn)
		 (add-recompile l fn (call-sig h) sig)))
	     (setf (call-sig h) sig))
	   (when src (setf (call-src h) src))
	   (let (ar)
	     (dolist (l callees (unless ar (when sig (remove-recompile fn))))
	       (pushnew (car l) (call-callees h))
	       (let ((h (or (gethash (car l) *call-hash-table*)
			    (setf (gethash (car l) *call-hash-table*) (make-call :sig (cdr l) :callers (list fn))))))
		 (pushnew fn (call-callers h))
		 (unless (or (eq fn (car l)) (equal (cdr l) (call-sig h)))
		   (add-recompile fn (car l) (cdr l) (call-sig h))
		   (setq ar t)))))))))

(defun clear-compiler-properties (sym code)
  (cond ((not (eq *boot* t))
	 (push `(clear-compiler-properties ',sym nil) *pahl*))
	((let ((h (or (gethash sym *call-hash-table*) 
		      (setf (gethash sym *call-hash-table*) (make-call)))))
	   (dolist (l (call-callees h))
	     (let ((l (gethash l *call-hash-table*)))
	       (setf (call-callers l) (delete sym (call-callers l)))))
	   (let (new)
	     (maphash (lambda (x y) 
			(when (and (fboundp x) (eq (symbol-function x) code) (call-src y))
			  (setq new x))) *call-hash-table*)
;	     (when (and (functionp code) (not (eq sym (function-name code))) (gethash (function-name code) *call-hash-table*) (not new))
;	       (format t  "setf symbol function ~s ~s~%" sym (function-name code)))
;	     (when (string= "MAKE-METHOD-LAMBDA" (symbol-name sym))
;	       (format t  "setf symbol function ~s code ~s~%" sym code))
	     (cond (new
		    (let ((nr (find new *needs-recompile* :key 'car)))
		      (when nr (add-recompile sym (cadr nr) (caddr nr) (cadddr nr))))
		    (setq new (gethash new *call-hash-table*))
		    (let ((ns (call-sig new)))
		      (unless (equal ns (call-sig h))
			(dolist (l (call-callers h))
			  (add-recompile l sym (call-sig h) ns)))
		      (setf (call-sig h) ns)
		      (proclaim `(ftype (function ,@ns) ,sym)))
		    (dolist (l (call-callees new)) 
		      (pushnew sym (call-callers (gethash l *call-hash-table*))))
		    (setf (call-callees h) (call-callees new) (call-src h) (call-src new)))
		   ((progn
		      (remove-recompile sym)
		      (setf (call-callees h) nil (call-src h) nil)))))))))

(defun add-recompile (fn why assumed-sig actual-sig)
  (unless (find fn *needs-recompile* :key 'car)
;    (format t "add-recompile ~s ~s ~s ~s~%" fn why assumed-sig actual-sig)
    (vector-push-extend (list fn why assumed-sig actual-sig) *needs-recompile*)
    nil))

(defun remove-recompile (fn)
  (let ((p (position fn *needs-recompile* :key 'car)))
    (when p
;      (format t "removing recompile of ~s~%" fn)
      (decf (fill-pointer *needs-recompile*))
      (do ((i p (1+ i))) ((= i (length *needs-recompile*)))
	(setf (aref *needs-recompile* i) (aref *needs-recompile* (1+ i)))))))

(defun clr-call nil 
  (clrhash *call-hash-table*)
  (setf (fill-pointer *needs-recompile*) 0))


(defun all-callees (x y)
  (let ((z (gethash x *ach*)))
    (if z (union z y)
      (let ((z (call-callees (gethash x *call-hash-table*))))
	(do ((l (set-difference z y) (cdr l))
	     (r (union z y) (all-callees (car l) r)))
	    ((endp l) 
	     (unless (intersection z y) (setf (gethash x *ach*) (set-difference r y)))
	     r))))))

(defun all-callers (x y)
  (let ((z (gethash x *acr*)))
    (if z (union z y)
      (let ((z (call-callers (gethash x *call-hash-table*))))
	(do ((l (set-difference z y) (cdr l))
	     (r (union z y) (all-callers (car l) r)))
	    ((endp l) 
	     (unless (intersection z y) (setf (gethash x *acr*) (set-difference r y)))
	     r))))))

(defun block-lambda (ll block body)
  (let* ((z body)
	 (doc (when (and z (stringp (car z))) (list (pop z))))
	 (decls (let (d) (do nil ((or (not z) (not (consp (car z))) (not (eq (caar z) 'declare))) (nreverse d))
			      (push (pop z) d))))
	 (rest z))
  `(lambda ,ll ,@doc ,@decls (block ,block ,@rest))))
       

(defun function-lambda-expression (x) 
  (if (typep x 'interpreted-function) 
      (let* ((x (si::interpreted-function-lambda x)))
	(case (car x)
	      (lambda (values x nil nil))
	      (lambda-block (values (block-lambda (caddr x) (cadr x) (cdddr x)) nil (cadr x)))
	      (lambda-closure (values (cons 'lambda (cddr (cddr x)))  (not (not (cadr x)))  nil))
	      (lambda-block-closure (values (block-lambda (caddr (cdddr x)) (cadr (cdddr x)) (cddr (cddr (cddr x)))) 
				     (not (not (cadr x))) (fifth x)))
	      (otherwise (values nil t nil))))
    (values nil t nil)))

(defun function-src (sym)
  (or
   (let* ((h (gethash sym *call-hash-table*))
	  (fas (when h (call-src h))))
     (when fas
       (let* ((ss (open-fasd (make-string-input-stream fas) :input 'eof nil))
	      (out (read-fasd-top ss)))
	 (close-fasd ss)
	 out)))
   (and (fboundp sym) (typep (symbol-function sym) 'interpreted-function) (function-lambda-expression (symbol-function sym)))))

(defun inlinef (n syms)
  (let* ((fns (mapcar 'si::function-src syms))
	 (sts (let (sts) (dotimes (i (length syms) (nreverse sts)) (push i sts))))
	 (lsst (1- (length sts)))
	 (ll (cadr (car fns))))
    `(defun ,n ,(cons 'state ll)
       (declare (fixnum state))
       ,@(let (d (z (cddr (car fns)))) 
	   (when (stringp (car z)) (pop z))
	   (do nil ((or (not z) (not (consp (car z))) (not (eq (caar z) 'declare))) (nreverse d)) (push (pop z) d)))
       (macrolet ,(mapcan (lambda (x y z) `((,x ,(cadr y) `(,',n ,,z ,,@(cadr y))))) syms fns sts)
	 (case state
	   ,@(mapcar (lambda (x y) `(,(if (= x lsst) 'otherwise x) (funcall ,y ,@ll))) sts fns))))))

(defun convert-to-state (sym)
  (let* ((n (intern (symbol-name (gensym (symbol-name sym))) (symbol-package sym)))
	 (syms (intersection (all-callees sym nil) (all-callers sym nil)))
	 (sts (let (sts) (dotimes (i (length syms) (nreverse sts)) (push i sts))))
	 (ns (inlinef n syms)))
    (eval ns)
    (mapc (lambda (x y) (let ((z (cdr (caddr ns)))) (eval `(defun ,x ,z (,n ,y ,@z))))) syms sts)
    (dolist (l syms) (add-hash l nil (list (list n)) nil))
    n))
    
(defun temp-prefix nil
  (concatenate 'string *tmp-dir* "gazonk_" (write-to-string (abs (si::getpid))) "_"))

(defun recompile (fn)
  (with-temp-file 
      (s tpn) ((temp-prefix) "lsp")
      (let ((*print-radix* nil)
	    (*print-base* 10)
	    (*print-circle* t)
	    (*print-pretty* nil)
	    (*print-level* nil)
	    (*print-length* nil)
	    (*print-case* :downcase)
	    (*print-gensym* t)
	    (*print-array* t)
	    (si::*print-package* t)
	    (si::*print-structure* t))
	(let* ((src (function-src fn)))
	  (if src (prin1 `(defun ,fn ,@(cdr src)) s)
	    (remove-recompile fn))
	  (let ((o (compile-file tpn)))
	    (load o)
	    (delete-file o))))))

(defun get-temp-dir ()
  (dolist (x `(,@(mapcar 'si::getenv '("TMPDIR" "TMP" "TEMP")) "/tmp" ""))
    (when x
      (let* ((x (pathname x))
	     (x (if (pathname-name x) x 
		  (merge-pathnames
		   (make-pathname :directory (butlast (pathname-directory x)) 
				  :name (car (last (pathname-directory x))))
		   x))))
	(when (directory x) 
	  (return-from 
	   get-temp-dir 
	   (namestring 
	    (make-pathname 
	     :device (pathname-device x)
	     :directory (when (or (pathname-directory x) (pathname-name x))
			  (append (pathname-directory x) (list (pathname-name x))))))))))))

(defun do-recompile (&optional pn)
  (unless (or *disable-recompile* (= 0 (length *needs-recompile*)))
    (let ((*disable-recompile* t))
      (clrhash *ach*)
      (clrhash *acr*)
      (sort *needs-recompile*
	    (lambda (x y) 
	      (member (car x) (all-callees (car y) nil))))
;      (maphash (lambda (x y) (when (call-sig y) (proclaim `(ftype (function ,@(call-sig y)) ,x)))) *call-hash-table*)
      (map nil (lambda (fn)
		 (format t "Callee ~s sigchange ~s to ~s, recompiling ~s~%" 
			 (cadr fn) (caddr fn) (cadddr fn) (car fn))) *needs-recompile*)
      (let ((f (when pn (open1 pn :direction :output :if-exists :append :if-does-not-exist :create))))
	(with-temp-file 
	    (s tpn) ((temp-prefix) "lsp")
	    (let ((*print-radix* nil)
		  (*print-base* 10)
		  (*print-circle* t)
		  (*print-pretty* nil)
		  (*print-level* nil)
		  (*print-length* nil)
		  (*print-case* :downcase)
		  (*print-gensym* t)
		  (*print-array* t)
		  (si::*print-package* t)
		  (si::*print-structure* t))
	      (dotimes (i (length *needs-recompile*))
		(let* ((fn (car (aref *needs-recompile* i)))
		       (src (function-src fn)))
		  (cond (src 
			 (prin1 `(defun ,fn ,@(cdr src)) s)
			 (when f (prin1 `(defun ,fn ,@(cdr src)) f)))
			((remove-recompile fn))))))
	    (when f (close f))
	    (let ((o (compile-file tpn)))
	      (load o)
	      (delete-file o)))))
    (cond ((> (length *needs-recompile*) 0) (do-recompile pn))
	  (pn (compile-file pn :system-p t :c-file t :h-file t :data-file t)))))

;FIXME!!!
(defun is-eq-test-item-list (x y z w)
  (format t "Should never be called ~s ~s ~s ~s~%" x y z w))

(defun cmp-vec-length (x)
  (declare (vector x))
  (if (array-has-fill-pointer-p x) (fill-pointer x) (array-dimension x 0)))

