(si::fset 'intersection #'si::intersection-eq)
(si::fset 'union #'si::union-eq)
(si::fset 'set-difference #'si::set-difference-eq)
(si::fset 'nunion #'si::nunion-eq)

;(make-package "COMPILER" :use '(lisp))
(in-package 'si)
(*make-special '*pahl*)
(setq *pahl* nil)
(defun do-recompile (&rest r) nil)
(defun add-hash (&rest r)
  (setq *pahl* (cons (cons 'add-hash (mapcar #'(lambda (x) `',x) r)) *pahl*)))

;(make-package "COMPILER" :use '(lisp))
;(defun proclaim (&rest r) nil);FIXME
;(defun si::maybe-clear-tp (&rest r) nil);FIXME
;(load1 "../lsp/gcl_callhash.lsp")
;(defun si::mdl (&rest r) nil);FIXME

;(load1 "../lsp/gcl_defmacro.lsp")
;(load1 "../lsp/gcl_evalmacros.lsp")
;(load1 "../lsp/gcl_top.lsp")
;(load1 "../lsp/gcl_module.lsp")
;(load1 "../lsp/gcl_autoload.lsp")
;(make-package "COMPILER" :use '(lisp))
;(load1 "../lsp/gcl_predlib.lsp")
;(load1 "../lsp/gcl_arraylib.lsp")
;(load1 "../lsp/gcl_assert.lsp")
;(load1 "../lsp/gcl_setf.lsp")
;(load1 "../lsp/gcl_defstruct.lsp")
;(load1 "../lsp/gcl_seqlib.lsp")
;(load1 "../lsp/gcl_mislib.lsp")
;(load1 "../lsp/gcl_numlib.lsp")
;(load1 "../lsp/gcl_seq.lsp")
;(load1 "../cmpnew/gcl_cmptype.lsp")
