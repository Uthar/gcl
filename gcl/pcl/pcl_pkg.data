       
#(#! 
(lisp::in-package :user)#! 
(lisp::export (lisp::intern (lisp::symbol-name :iterate) (lisp::find-package :iterate)) (lisp::find-package :iterate))#! 
(lisp::in-package :walker)#! 
(lisp::export (lisp::quote (walker::define-walker-template walker::walk-form walker::walk-form-expand-macros-p walker::nested-walk-form walker::variable-lexical-p walker::variable-special-p walker::variable-globally-special-p walker::*variable-declarations* walker::variable-declaration walker::macroexpand-all)))#! 
(lisp::in-package :iterate)#! 
(lisp::export (lisp::quote (iterate::iterate iterate::iterate* iterate::gathering iterate::gather iterate::with-gathering iterate::interval iterate::elements iterate::list-elements iterate::list-tails iterate::plist-elements iterate::eachtime iterate::while iterate::until iterate::collecting iterate::joining iterate::maximizing iterate::minimizing iterate::summing iterate::*iterate-warnings*)))#! 
(lisp::in-package :pcl)#! 
(lisp::import (lisp::quote (system::structurep system::structure-def system::structure-ref)))#! 
(lisp::shadow (lisp::quote lisp::dotimes))#! 
(lisp::in-package "SI")#! 
(lisp::export (lisp::quote (system::%structure-name system::%compiled-function-name system::%set-compiled-function-name system::%instance-ref system::%set-instance-ref)))#! 
(lisp::in-package (lisp::quote system::pcl))#! 
(lisp::shadow (lisp::quote pcl::documentation))
#(lisp::*package* pcl::*the-pcl-package* (system::%init . #((lisp::if (lisp::find-package (lisp::quote :walker)) (lisp::use-package (lisp::quote (:lisp)) (lisp::quote :walker)) (lisp::make-package (lisp::quote :walker) :use (lisp::quote (:lisp)))) (lisp::if (lisp::find-package (lisp::quote :iterate)) (lisp::use-package (lisp::quote (:lisp :walker)) (lisp::quote :iterate)) (lisp::make-package (lisp::quote :iterate) :use (lisp::quote (:lisp :walker)))) (lisp::if (lisp::find-package (lisp::quote :pcl)) (lisp::use-package (lisp::quote (:walker :iterate :lisp)) (lisp::quote :pcl)) (lisp::make-package (lisp::quote :pcl) :use (lisp::quote (:walker :iterate :lisp)))) (system::mfvfun (lisp::quote pcl::use-package-pcl) 0 256) (system::*make-special (lisp::quote pcl::*exports*)) (lisp::or (lisp::boundp (lisp::quote pcl::*exports*)) (lisp::setq pcl::*exports* (lisp::quote (pcl::add-method lisp::built-in-class pcl::call-method pcl::call-next-method pcl::change-class pcl::class-name pcl::class-of pcl::compute-applicable-methods pcl::defclass pcl::defgeneric pcl::define-method-combination pcl::defmethod pcl::ensure-generic-function pcl::find-class pcl::find-method pcl::function-keywords pcl::generic-flet pcl::generic-labels pcl::initialize-instance pcl::invalid-method-error pcl::make-instance pcl::make-instances-obsolete pcl::method-combination-error pcl::method-qualifiers pcl::next-method-p pcl::no-applicable-method pcl::no-next-method pcl::print-object pcl::reinitialize-instance pcl::remove-method pcl::shared-initialize pcl::slot-boundp pcl::slot-exists-p pcl::slot-makunbound pcl::slot-missing pcl::slot-unbound pcl::slot-value pcl::standard lisp::standard-class lisp::standard-generic-function lisp::standard-method lisp::standard-object lisp::structure-class pcl::symbol-macrolet pcl::update-instance-for-different-class pcl::update-instance-for-redefined-class pcl::with-accessors pcl::with-added-methods pcl::with-slots)))) (lisp::mapc (lisp::quote lisp::export) (lisp::list pcl::*exports*) (lisp::list pcl::*the-pcl-package*)) (system::*make-special (lisp::quote pcl::*class-exports*)) (lisp::or (lisp::boundp (lisp::quote pcl::*class-exports*)) (lisp::setq pcl::*class-exports* (lisp::quote (pcl::standard-instance pcl::funcallable-standard-instance lisp::generic-function lisp::standard-generic-function lisp::method lisp::standard-method pcl::standard-accessor-method pcl::standard-reader-method pcl::standard-writer-method lisp::method-combination pcl::slot-definition pcl::direct-slot-definition pcl::effective-slot-definition pcl::standard-slot-definition pcl::standard-direct-slot-definition pcl::standard-effective-slot-definition pcl::specializer pcl::eql-specializer lisp::built-in-class pcl::forward-referenced-class lisp::standard-class pcl::funcallable-standard-class)))) (system::*make-special (lisp::quote pcl::*chapter-6-exports*)) (lisp::or (lisp::boundp (lisp::quote pcl::*chapter-6-exports*)) (lisp::setq pcl::*chapter-6-exports* (lisp::quote (pcl::add-dependent pcl::add-direct-method pcl::add-direct-subclass pcl::add-method pcl::allocate-instance pcl::class-default-initargs pcl::class-direct-default-initargs pcl::class-direct-slots pcl::class-direct-subclasses pcl::class-direct-superclasses pcl::class-finalized-p pcl::class-precedence-list pcl::class-prototype pcl::class-slots pcl::compute-applicable-methods pcl::compute-applicable-methods-using-classes pcl::compute-class-precedence-list pcl::compute-discriminating-function pcl::compute-effective-method pcl::compute-effective-slot-definition pcl::compute-slots pcl::direct-slot-definition-class pcl::effective-slot-definition-class pcl::ensure-class pcl::ensure-class-using-class pcl::ensure-generic-function pcl::ensure-generic-function-using-class pcl::eql-specializer-instance pcl::extract-lambda-list pcl::extract-specializer-names pcl::finalize-inheritance pcl::find-method-combination pcl::funcallable-standard-instance-access pcl::generic-function-argument-precedence-order pcl::generic-function-declarations pcl::generic-function-lambda-list pcl::generic-function-method-class pcl::generic-function-method-combination pcl::generic-function-methods pcl::generic-function-name pcl::intern-eql-specializer pcl::make-instance pcl::make-method-lambda pcl::map-dependents pcl::method-function pcl::method-generic-function pcl::method-lambda-list pcl::method-specializers pcl::method-qualifiers pcl::accessor-method-slot-definition pcl::reader-method-class pcl::remove-dependent pcl::remove-direct-method pcl::remove-direct-subclass pcl::remove-method pcl::set-funcallable-instance-function pcl::slot-boundp-using-class pcl::slot-definition-allocation pcl::slot-definition-initargs pcl::slot-definition-initform pcl::slot-definition-initfunction pcl::slot-definition-location pcl::slot-definition-name pcl::slot-definition-readers pcl::slot-definition-writers pcl::slot-definition-type pcl::slot-makunbound-using-class pcl::slot-value-using-class pcl::specializer-direct-generic-function pcl::specializer-direct-methods pcl::standard-instance-access pcl::update-dependent pcl::validate-superclass pcl::writer-method-class)))) (lisp::mapc (lisp::quote lisp::export) (lisp::list pcl::*class-exports*) (lisp::list pcl::*the-pcl-package*)) (lisp::mapc (lisp::quote lisp::export) (lisp::list pcl::*chapter-6-exports*) (lisp::list pcl::*the-pcl-package*)) (system::*make-special (lisp::quote pcl::*slot-accessor-name-package*)) (lisp::or (lisp::boundp (lisp::quote pcl::*slot-accessor-name-package*)) (lisp::setq pcl::*slot-accessor-name-package* (lisp::or (lisp::find-package :slot-accessor-name) (lisp::make-package :slot-accessor-name :use (lisp::quote lisp::nil) :nicknames (lisp::quote (:s-a-n)))))) (lisp::if (lisp::get (lisp::quote system::basic-wrapper) (lisp::quote system::s-data)) (lisp::progn (lisp::import (lisp::mapcar (lisp::function (lisp::lambda (pcl::s) (lisp::intern (lisp::symbol-name pcl::s) "SI"))) (lisp::quote (:copy-structure-header :swap-structure-contents :set-structure-def :%instance-ref :%set-instance-ref :cache-number-vector :cache-number-vector-length :wrapper-cache-number-adds-ok :wrapper-cache-number-length :wrapper-cache-number-mask :wrapper-cache-number-vector-length :wrapper-layout :wrapper-cache-number-vector :wrapper-state :wrapper-class :wrapper-length)))))))))
)
