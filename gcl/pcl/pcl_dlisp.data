       
#(#! 
(lisp::in-package :pcl)
#(:reader :writer pcl::*precompiling-lap* pcl::*emit-function-p* lisp::&rest (pcl::.lap-rest-arg.) (pcl::emf) pcl::invoke-effective-method-function pcl::emf (lisp::&rest pcl::.lap-rest-arg.) lisp::lambda pcl::miss-fn ((lisp::declare (lisp::type lisp::function pcl::miss-fn))) pcl::fin-lambda-fn lisp::let (lisp::declare (lisp::optimize (lisp::speed 3) (lisp::safety 0))) lisp::function lisp::number pcl::index pcl::slots conditions::case-failure :name conditions::ecase :datum :expected-type (lisp::member . #0=(:reader :writer)) :possibilities #0# 1 (pcl::wrapper-0 pcl::index pcl::miss-fn) 2 (pcl::wrapper-0 pcl::wrapper-1 pcl::index pcl::miss-fn) (lisp::member . #1=(1 2)) #1# lisp::let* ((pcl::slots lisp::nil)) pcl::wrapper lisp::cond pcl::std-instance-p lisp::setq pcl::std-instance-slots pcl::std-instance-wrapper pcl::fsc-instance-p pcl::fsc-instance-slots pcl::fsc-instance-wrapper (pcl::value) lisp::if lisp::or (lisp::null pcl::wrapper) lisp::zerop pcl::wrapper-cache-number-vector-ref lisp::not (lisp::eq pcl::wrapper pcl::wrapper-0) ((lisp::eq pcl::wrapper pcl::wrapper-1)) lisp::eq pcl::*slot-unbound* pcl::value lisp::funcall lisp::setf lisp::cdr pcl::%instance-ref (lisp::eq pcl::value pcl::*slot-unbound*) (lisp::member . #2=(:reader :writer)) #2# (pcl::standard-instance) (lisp::t pcl::standard-instance) (lisp::member . #3=(:reader :writer)) #3# pcl::cache (pcl::index) (pcl::miss-fn) (pcl::slots) (pcl::index) (pcl::slots) (pcl::.lap-rest-arg.) lisp::apply (pcl::.lap-rest-arg.) (pcl::emf) (pcl::miss-fn) (pcl::emf) "WRAPPER-~D" pcl::*the-pcl-package* pcl::miss "Every metatype is T." lisp::block pcl::dfun lisp::tagbody (pcl::field (pcl::cache-field pcl::cache)) (pcl::cache-vector (pcl::cache-vector pcl::cache)) (pcl::mask (pcl::cache-mask pcl::cache)) (pcl::size (pcl::cache-size pcl::cache)) (pcl::overflow (pcl::cache-overflow pcl::cache)) (lisp::declare (lisp::fixnum pcl::size pcl::field pcl::mask)) lisp::return-from pcl::primary (pcl::location pcl::primary) (lisp::declare (lisp::fixnum pcl::primary pcl::location)) lisp::search lisp::loop lisp::when (pcl::cache-vector-ref pcl::cache-vector pcl::location) (lisp::return-from lisp::search lisp::nil) (lisp::setq pcl::location (lisp::the lisp::fixnum (lisp::+ pcl::location 1))) (lisp::when (lisp::= pcl::location pcl::size) (lisp::setq pcl::location 0)) (lisp::= pcl::location pcl::primary) lisp::dolist (pcl::entry pcl::overflow) (lisp::car pcl::entry) (lisp::return-from lisp::search lisp::nil) lisp::go pcl::lock-count pcl::cache-vector-lock-count ((lisp::unless (lisp::typep pcl::lock-count (lisp::quote lisp::fixnum)) (lisp::error "my cache got freed somehow")) (lisp::the lisp::fixnum pcl::lock-count)) (pcl::initial-lock-count (pcl::get-cache-vector-lock-count pcl::cache-vector)) (lisp::declare (lisp::fixnum pcl::primary pcl::initial-lock-count)) ((pcl::location pcl::primary)) (lisp::declare (lisp::fixnum pcl::location)) (pcl::cache-vector-ref pcl::cache-vector pcl::location) (pcl::cache-vector-ref pcl::cache-vector (lisp::1+ pcl::location)) (lisp::return-from lisp::search lisp::nil) (lisp::setq pcl::location (lisp::the lisp::fixnum (lisp::+ pcl::location 2))) (lisp::when (lisp::= pcl::location pcl::size) (lisp::setq pcl::location 0)) (lisp::= pcl::location pcl::primary) (pcl::entry pcl::overflow) (lisp::car pcl::entry) (lisp::cdr pcl::entry) (lisp::return-from lisp::search lisp::nil) lisp::unless (lisp::= pcl::initial-lock-count (pcl::get-cache-vector-lock-count pcl::cache-vector)) ((pcl::primary 0) (pcl::size-1 (lisp::the lisp::fixnum (lisp::- pcl::size 1)))) (lisp::declare (lisp::fixnum pcl::primary pcl::size-1)) ((pcl::initial-lock-count (pcl::get-cache-vector-lock-count pcl::cache-vector))) (lisp::declare (lisp::fixnum pcl::initial-lock-count)) ((pcl::location pcl::primary) (pcl::next-location 0)) (lisp::declare (lisp::fixnum pcl::location pcl::next-location)) pcl::next-location lisp::the lisp::fixnum lisp::+ pcl::location lisp::and (pcl::cache-vector-ref pcl::cache-vector (lisp::setq pcl::location (lisp::the lisp::fixnum (lisp::+ pcl::location 1)))) (lisp::setq pcl::location (lisp::the lisp::fixnum (lisp::+ pcl::location 1))) (pcl::cache-vector-ref pcl::cache-vector pcl::location) ((lisp::return-from lisp::search lisp::nil)) (lisp::setq pcl::location pcl::next-location) (lisp::when (lisp::= pcl::location pcl::size-1) (lisp::setq pcl::location 0)) (lisp::= pcl::location pcl::primary) (pcl::entry pcl::overflow) ((pcl::entry-wrappers (lisp::car pcl::entry))) (lisp::pop pcl::entry-wrappers) (lisp::cdr pcl::entry) ((lisp::return-from lisp::search lisp::nil)) (lisp::= pcl::initial-lock-count (pcl::get-cache-vector-lock-count pcl::cache-vector)) pcl::wrapper-cache-no pcl::field (lisp::declare (lisp::fixnum pcl::wrapper-cache-no)) (lisp::zerop pcl::wrapper-cache-no) (lisp::logand pcl::mask pcl::wrapper-cache-no) lisp::progn (lisp::declare (lisp::fixnum pcl::wrapper-cache-no)) (lisp::zerop pcl::wrapper-cache-no) (lisp::setq pcl::primary (lisp::the lisp::fixnum (lisp::+ pcl::primary pcl::wrapper-cache-no))) (lisp::logand pcl::primary pcl::mask) "Can't do a slot reg for this metatype." pcl::wrapper-of-macro "Can't do a slot reg for this metatype." pcl::built-in-or-structure-wrapper (lisp::member . #4=(pcl::standard-instance lisp::class pcl::built-in-instance pcl::structure-instance)) #4# pcl::emit-reader/writer pcl::emit-one-or-n-index-reader/writer pcl::emit-checking-or-caching pcl::emit-default-only-function pcl::make-dlap-lambda-list lisp::remove pcl::generating-lisp pcl::emit-default-only pcl::compile-lambda pcl::emit-reader/writer-function pcl::wrapper-field pcl::emit-slot-read-form pcl::dfun-arg-symbol conditions::error pcl::emit-boundp-check pcl::emit-one-or-n-index-reader/writer-function pcl::emit-dlap pcl::emit-slot-access pcl::emit-checking-or-caching-function pcl::emit-miss pcl::emit-fetch-wrapper pcl::emit-greater-than-1-dlap pcl::emit-1-t-dlap pcl::emit-1-nil-dlap pcl::emit-1-wrapper-compute-primary-cache-location pcl::compute-line-size pcl::emit-n-wrapper-compute-primary-cache-location pcl::standard-instance lisp::class pcl::built-in-instance pcl::structure-instance (system::%init . #((system::mf (lisp::quote pcl::emit-one-class-reader) 0) (system::mf (lisp::quote pcl::emit-one-class-writer) 1) (system::mf (lisp::quote pcl::emit-two-class-reader) 2) (system::mf (lisp::quote pcl::emit-two-class-writer) 3) (system::mf (lisp::quote pcl::emit-one-index-readers) 4) (system::mf (lisp::quote pcl::emit-one-index-writers) 5) (system::mf (lisp::quote pcl::emit-n-n-readers) 6) (system::mf (lisp::quote pcl::emit-n-n-writers) 7) (system::mf (lisp::quote pcl::emit-checking) 8) (system::mf (lisp::quote pcl::emit-caching) 9) (system::mf (lisp::quote pcl::emit-in-checking-cache-p) 10) (system::mf (lisp::quote pcl::emit-constant-value) 11) (system::*make-special (lisp::quote pcl::*precompiling-lap*)) (lisp::or (lisp::boundp (lisp::quote pcl::*precompiling-lap*)) (lisp::setq pcl::*precompiling-lap* lisp::nil)) (system::*make-special (lisp::quote pcl::*emit-function-p*)) (lisp::or (lisp::boundp (lisp::quote pcl::*emit-function-p*)) (lisp::setq pcl::*emit-function-p* lisp::t)) (system::mf (lisp::quote pcl::emit-default-only) 12) (system::mm (lisp::quote pcl::emit-default-only-macro) 13) (system::mf (lisp::quote pcl::generating-lisp) 14) (system::mf (lisp::quote pcl::emit-reader/writer) 15) (system::mfsfun (lisp::quote pcl::emit-slot-read-form) 16 3) (system::mfsfun (lisp::quote pcl::emit-boundp-check) 17 3) (system::mfsfun (lisp::quote pcl::emit-slot-access) 18 6) (system::mm (lisp::quote pcl::emit-reader/writer-macro) 19) (system::mf (lisp::quote pcl::emit-one-or-n-index-reader/writer) 20) (system::mm (lisp::quote pcl::emit-one-or-n-index-reader/writer-macro) 21) (system::mfvfun (lisp::quote pcl::emit-miss) 22 770) (system::mf (lisp::quote pcl::emit-checking-or-caching) 23) (system::mm (lisp::quote pcl::emit-checking-or-caching-macro) 24) (system::mfvfun (lisp::quote pcl::emit-dlap) 25 1541) (system::mfsfun (lisp::quote pcl::emit-1-nil-dlap) 26 2) (system::mm (lisp::quote pcl::get-cache-vector-lock-count) 27) (system::mfsfun (lisp::quote pcl::emit-1-t-dlap) 28 3) (system::mfsfun (lisp::quote pcl::emit-greater-than-1-dlap) 29 3) (system::mfsfun (lisp::quote pcl::emit-1-wrapper-compute-primary-cache-location) 30 2) (system::mfsfun (lisp::quote pcl::emit-n-wrapper-compute-primary-cache-location) 31 2) (system::mfvfun (lisp::quote pcl::emit-fetch-wrapper) 32 1027) (system::debug (lisp::quote pcl::emit-one-class-reader) (lisp::quote (pcl::class-slot-p))) (system::debug (lisp::quote pcl::emit-one-class-writer) (lisp::quote (pcl::class-slot-p))) (system::debug (lisp::quote pcl::emit-two-class-reader) (lisp::quote (pcl::class-slot-p))) (system::debug (lisp::quote pcl::emit-two-class-writer) (lisp::quote (pcl::class-slot-p))) (system::debug (lisp::quote pcl::emit-one-index-readers) (lisp::quote (pcl::class-slot-p))) (system::debug (lisp::quote pcl::emit-one-index-writers) (lisp::quote (pcl::class-slot-p))) (system::debug (lisp::quote pcl::emit-checking) (lisp::quote (pcl::metatypes pcl::applyp))) (system::debug (lisp::quote pcl::emit-caching) (lisp::quote (pcl::metatypes pcl::applyp))) (system::debug (lisp::quote pcl::emit-in-checking-cache-p) (lisp::quote (pcl::metatypes))) (system::debug (lisp::quote pcl::emit-constant-value) (lisp::quote (pcl::metatypes))) (system::debug (lisp::quote pcl::emit-default-only) (lisp::quote (pcl::metatypes pcl::applyp pcl::dlap-lambda-list pcl::args pcl::restl))) (system::debug (lisp::quote pcl::generating-lisp) (lisp::quote (pcl::closure-variables pcl::args pcl::form lisp::rest lisp::ldiff pcl::args lisp::lambda))) (system::debug (lisp::quote pcl::emit-reader/writer) (lisp::quote (pcl::reader/writer pcl::1-or-2-class pcl::class-slot-p))) (system::debug (lisp::quote pcl::emit-one-or-n-index-reader/writer) (lisp::quote (pcl::reader/writer pcl::cached-index-p pcl::class-slot-p))) (system::debug (lisp::quote pcl::emit-miss) (lisp::quote (pcl::miss-fn pcl::args pcl::applyp))) (system::debug (lisp::quote pcl::emit-checking-or-caching) (lisp::quote (pcl::cached-emf-p pcl::return-value-p pcl::metatypes pcl::applyp pcl::dlap-lambda-list pcl::args pcl::restl))) (system::debug (lisp::quote pcl::emit-dlap) (lisp::quote (pcl::wrapper-bindings pcl::wrappers pcl::hit pcl::miss pcl::value-reg pcl::slot-regs))) (system::debug (lisp::quote pcl::emit-fetch-wrapper) (lisp::quote (pcl::metatype pcl::argument pcl::miss-label pcl::slot))))))
)
