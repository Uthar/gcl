       
#(#! 
(lisp::in-package :pcl)
#(:argument-precedence-order lisp::quote :declarations :documentation :method-combination :generic-function-class :method-class pcl::defmethod pcl::methods "The option ~S appears more than once." lisp::progn pcl::proclaim-defgeneric pcl::defgeneric pcl::*defgeneric-times* pcl::load-defgeneric :lambda-list :definition-source pcl::*boot-state* pcl::complete lisp::standard-generic-function lisp::standard-method pcl::*make-instance-function-keys* pcl::*optimize-asv-funcall-p* pcl::*asv-readers* pcl::*asv-writers* pcl::*asv-boundps* pcl::get-make-instance-functions pcl::initialize-internal-slot-gfs* :plist :pv-table-symbol lisp::setf lisp::eql lisp::list* (:function :fast-function) lisp::function lisp::lambda :function lisp::method pcl::fast-method lisp::*print-pretty* "~S" lisp::eval-when pcl::*defmethod-times* lisp::defun lisp::list pcl::load-defmethod lisp::declare pcl::method-name pcl::method-lambda-list "The method-lambda argument to make-method-function, ~S,~
            is not a lambda form" "The method-lambda argument to make-method-lambda, ~S,~
            is not a lambda form" lisp::class lisp::block (lisp::or lisp::number lisp::character) :constant-value (lisp::&optional lisp::&rest lisp::&key) lisp::&aux :needs-next-methods-p "pv-table" :slot-name-lists :call-list pcl::pv-binding lisp::&key lisp::&allow-other-keys (pcl::.method-args. pcl::.next-methods.) pcl::simple-lexical-method-functions pcl::.method-args. pcl::.next-methods. :call-next-method-p :next-method-p-p :closurep :applyp pcl::bind-simple-lexical-method-macros pcl::bind-lexical-method-functions pcl::bind-args pcl::bind-fast-lexical-method-macros lisp::macrolet pcl::call-next-method-bind (lisp::&body pcl::body) (lisp::quote lisp::let) (lisp::quote pcl::.next-method.) (lisp::quote lisp::car) (lisp::quote lisp::cdr) (lisp::quote pcl::.next-method.) pcl::body pcl::call-next-method-body (pcl::cnm-args) (lisp::quote lisp::if) (lisp::quote pcl::.next-method.) (lisp::quote lisp::funcall) (lisp::quote (lisp::the lisp::function (lisp::if (pcl::std-instance-p pcl::.next-method.) (pcl::method-function pcl::.next-method.) pcl::.next-method.))) (lisp::quote lisp::or) pcl::cnm-args (lisp::quote (lisp::error "No next method.")) (pcl::next-method-p-body lisp::nil (lisp::quote (lisp::not (lisp::null pcl::.next-method.)))) pcl::method-call lisp::let pcl::.function. pcl::.args. pcl::.cm-args. ((lisp::declare (lisp::type lisp::function pcl::.function.)) (lisp::if (lisp::and pcl::.cm-args. (lisp::null (lisp::cdr pcl::.cm-args.))) (lisp::funcall pcl::.function. pcl::.args. (lisp::car pcl::.cm-args.)) (lisp::apply pcl::.function. pcl::.args. pcl::.cm-args.))) pcl::invoke-method-call1 pcl::method-call-function pcl::method-call-call-method-args pcl::fast-method-call pcl::fmc-funcall pcl::fast-method-call-function pcl::fast-method-call-pv-cell pcl::fast-method-call-next-method-call pcl::fast-instance-boundp pcl::*emf-call-trace* pcl::emf-call-trace-index pcl::*enable-emf-call-tracing-p* "~&(The oldest entries are printed first)~%" pcl::*emf-call-trace-size* pcl::*allow-emf-call-tracing-p* lisp::when pcl::trace-emf-call-internal pcl::trace-emf-call pcl::invoke-fast-method-call "The restp argument to invoke-effective-method-function is not constant" lisp::cond lisp::typep (lisp::quote pcl::fast-method-call) (lisp::quote lisp::fixnum) lisp::let* pcl::.slots. pcl::get-slots-or-nil pcl::value pcl::%instance-ref lisp::if lisp::eq pcl::*slot-unbound* pcl::slot-unbound-internal (lisp::quote lisp::fixnum) pcl::.new-value. lisp::etypecase pcl::invoke-method-call lisp::apply lisp::the lisp::funcall "wrong number of args" "wrong number of args" "wrong number of args" "1 or 2 args expected" lisp::nil pcl::std-instance pcl::*funcallable-instance-marker* "What kind of instance is this?" lisp::nil "1 or 2 args expected" "1 arg expected" lisp::nil pcl::emf (pcl::fast-method-call pcl::method-call lisp::fixnum pcl::fast-instance-boundp lisp::function) (pcl::fast-method-call pcl::method-call lisp::function) (pcl::fast-method-call pcl::method-call lisp::function) (pcl::call-next-method-bind (lisp::&body pcl::body) (lisp::list* (lisp::quote lisp::let) lisp::nil pcl::body)) (pcl::cnm-args) (lisp::quote lisp::if) lisp::and lisp::null ((lisp::consp pcl::cnm-args) (lisp::eq (lisp::car pcl::cnm-args) (lisp::quote lisp::list))) (lisp::quote pcl::invoke-effective-method-function) (lisp::nil (lisp::cdr pcl::cnm-args)) pcl::call (lisp::quote pcl::invoke-effective-method-function) lisp::append (lisp::quote lisp::if) (lisp::quote pcl::bind-args) lisp::&rest (lisp::quote (lisp::error "No next method.")) pcl::next-method-p-body (lisp::quote lisp::not) (lisp::quote lisp::null) ((pcl::call-next-method (lisp::&rest pcl::cnm-args) (lisp::list (lisp::quote pcl::call-next-method-body) (lisp::when pcl::cnm-args (lisp::list* (lisp::quote lisp::list) pcl::cnm-args)))) (pcl::next-method-p lisp::nil (lisp::quote (pcl::next-method-p-body)))) lisp::flet ((pcl::call-next-method (lisp::&rest pcl::cnm-args) (pcl::call-next-method-body pcl::cnm-args))) ((pcl::next-method-p lisp::nil (pcl::next-method-p-body))) pcl::.args-tail. pcl::.key. pcl::required lisp::ignore lisp::nil pcl::optional pcl::key lisp::rest pcl::aux "Encountered the non-standard lambda list keyword ~S." lisp::pop pcl::get-key-arg pcl::get-key-arg1 lisp::consp lisp::car :eval pcl::call-next-method pcl::next-method-p pcl::slot-value pcl::set-slot-value pcl::slot-boundp pcl::asv-funcall "In defmethod ~S, there is a~%~
                      redundant ignore declaration for the parameter ~S." pcl::*mf1* pcl::*mf2* pcl::*mf2p* pcl::*mf1p* pcl::*mf2cp* pcl::*mf1cp* pcl::*method-function-plist* :pv-table :method pcl::method-function-get (lisp::quote pcl::closure-generator) :method-spec lisp::*error-output* "~&At the time the method with qualifiers ~:S and~%~
               specializers ~:S on the generic function ~S~%~
               was compiled, the method-class for that generic function was~%~
               ~S.  But, the method class is now ~S, this~%~
               may mean that this method was compiled improperly.~%" :fast-function pcl::fast-sym "FAST-~A" pcl::*the-pcl-package* :name "Encountered the non-standard lambda list keyword ~S." "KEYWORD" :initial-element (lisp::&optional) (lisp::&rest lisp::t) (lisp::&key) (lisp::&allow-other-keys) lisp::* compiler::proclaimed-closure "~S already names an ordinary function or a macro,~%~
                  you may want to replace it with a generic function, but doing so~%~
                  will require that you decide what to do with the existing function~%~
                  definition.~%~
                  The PCL-specific function MAKE-SPECIALIZABLE may be useful to you." lisp::nil pcl::*sgf-method-class-index* pcl::instance-ref pcl::get-slots pcl::*sgf-methods-index* pcl::*sgf-arg-info-index* :no-lambda-list pcl::arg-info "value" lisp::unless lisp::equal lisp::nil lisp::nil "The lambda-list ~S is incompatible with ~
                     existing methods of ~S." "the method has ~A required arguments than the generic function." "the method has ~S optional arguments than the generic function." "the method and generic function differ in whether they accept~%~
                  rest or keyword arguments." "the method does not accept each of the keyword arguments~%~
                 ~S." "Attempt to add the method ~S to the generic function ~S.~%~
                   But ~A" "more" "fewer" pcl::*standard-method-combination* pcl::*the-class-standard-reader-method* pcl::reader pcl::*the-class-standard-writer-method* pcl::writer pcl::*the-class-standard-boundp-method* lisp::boundp #\Space (lisp::lambda) pcl::*generic-function-fixups* "The function ~S is not already defined" "~S should be on the list ~S" pcl::*early-generic-functions* :test pcl::*sgf-wrapper* pcl::*sgf-slots-init* pcl::print-object "#<" "std-instance" " " ">" "The function of the funcallable-instance ~S~
                       has not been set" pcl::name pcl::source lisp::nil pcl::cache lisp::nil pcl::*sgf-dfun-state-index* lisp::nil lisp::nil lisp::nil pcl::*sgf-name-index* lisp::nil lisp::nil "No way to determine the lambda list for ~S." (lisp::&allow-other-keys) lisp::symbolp lisp::setq pcl::find-class pcl::classp lisp::error "The :GENERIC-FUNCTION-CLASS argument (~S) was neither a~%~
                    class nor a symbol that names a class." lisp::remf :environment pcl::combin lisp::getf (:method-combination (lisp::quote pcl::.shes-not-there.)) (lisp::eq pcl::combin (lisp::quote pcl::.shes-not-there.)) pcl::find-method-combination pcl::class-prototype ((lisp::car pcl::combin) (lisp::cdr pcl::combin)) pcl::.shes-not-there. lisp::nil :early-method :qualifiers :specializers :slot-name :allow-other-keys pcl::standard-reader-method pcl::standard-writer-method pcl::standard-boundp-method "~S is not an early-method." lisp::nil "Early add-method didn't get a funcallable instance." "Early add-method didn't get an early method." lisp::nil :new-method "Early remove-method didn't get a funcallable instance." "Early remove-method didn't get an early method." lisp::nil lisp::nil lisp::nil "Can't get early method." pcl::*fegf-debug-p* pcl::*fegf-started-p* lisp::nil (pcl::accessor-method-slot-name pcl::generic-function-methods pcl::method-specializers pcl::specializerp pcl::specializer-type pcl::specializer-class pcl::slot-definition-location pcl::slot-definition-name pcl::class-slots pcl::gf-arg-info pcl::class-precedence-list pcl::slot-boundp-using-class (lisp::setf pcl::slot-value-using-class) pcl::slot-value-using-class pcl::structure-class-p pcl::standard-class-p pcl::funcallable-standard-class-p pcl::specializerp) "~&~S..." lisp::nil pcl::*the-class-standard-method* pcl::*early-functions* "~S used as a specializer,~%~
                             but is not the name of a class." "~S is not a legal specializer." "~S is not a legal specializer." "~S" pcl::*the-class-t* (lisp::&optional lisp::&rest lisp::&key lisp::&allow-other-keys lisp::&aux) "Unrecognized lambda-list keyword ~S in arglist.~%~
                    Assuming that the symbols following it are parameters,~%~
                    and not allowing any parameter specializers to follow~%~
                    to follow it." (lisp::setq lisp::setf) lisp::multiple-value-setq lisp::multiple-value-bind pcl::variable-rebinding pcl::symbol-macrolet pcl::|SETF PCL GDEFINITION| pcl::set-function-name pcl::expand-defgeneric pcl::do-standard-defsetf-1 pcl::make-top-level-form pcl::load-truename pcl::ensure-generic-function pcl::parse-defmethod pcl::prototypes-for-make-method-lambda pcl::expand-defmethod pcl::gboundp pcl::gdefinition pcl::generic-function-p pcl::generic-function-method-class pcl::add-method-declarations pcl::make-method-lambda pcl::make-method-initargs-form pcl::make-defmethod-form pcl::class-of pcl::class-name pcl::interned-symbol-p lisp::every lisp::nil pcl::make-defmethod-form-internal pcl::make-method-function-internal pcl::parse-specialized-lambda-list pcl::extract-declarations pcl::make-method-initargs-form-internal pcl::make-method-lambda-internal pcl::get-declaration pcl::make-parameter-references lisp::remove pcl::walk-method-lambda lisp::cdr lisp::some pcl::slot-name-lists-from-slots :call-method-args lisp::identity :arg-info :next-method-call :pv-cell 0 :index lisp::make-array system::structure-subtype-p pcl::cclosure-env-nthcdr pcl::%cclosure-env-nthcdr system::typecase-error-string pcl::gf-arg-info pcl::arg-info-number-required pcl::arg-info-applyp walker::walk-form pcl::standard-generic-function-p lisp::warn pcl::method-function-plist pcl::|SETF PCL METHOD-FUNCTION-PLIST| pcl::make-method-spec pcl::record-definition pcl::load-defmethod-internal pcl::add-named-method pcl::intern-pv-table pcl::method-function-from-fast-function lisp::&optional pcl::analyze-lambda-list pcl::keyword-spec-name pcl::get-setf-function-name pcl::generic-clobbers-function pcl::ensure-generic-function-using-class :gf-info-fast-mf-p :gf-info-c-a-m-emf-std-p :gf-info-static-c-a-m-emf :gf-precompute-dfun-and-emf-p :gf-info-simple-accessor-type :arg-info-keywords :arg-info-key/rest-p :arg-info-number-optional :arg-info-metatypes :arg-info-precedence :arg-info-lambda-list lisp::nil lisp::count-if pcl::generic-function-methods pcl::gf-lambda-list pcl::compute-precedence pcl::check-method-arg-info pcl::set-arg-info1 pcl::early-method-lambda-list pcl::arg-info-valid-p pcl::method-specializers pcl::early-method-specializers pcl::early-method-class pcl::generic-function-method-combination pcl::raise-metatype pcl::early-gf-p pcl::compute-applicable-methods-emf pcl::generic-function-name pcl::early-gf-name lisp::find pcl::compute-applicable-methods pcl::make-early-gf pcl::allocate-funcallable-instance pcl::set-funcallable-instance-function pcl::bootstrap-set-slot pcl::make-arg-info pcl::set-arg-info pcl::|SETF PCL GF-DFUN-STATE| pcl::gf-dfun-state pcl::change-class pcl::reinitialize-instance pcl::make-instance lisp::nil pcl::initialize-method-function lisp::nil pcl::parse-specializers lisp::fifth lisp::seventh pcl::early-method-qualifiers pcl::make-a-method pcl::remove-method pcl::add-method pcl::update-dfun pcl::real-get-method pcl::early-method-standard-accessor-p lisp::delete pcl::real-make-a-method pcl::|SETF PCL GENERIC-FUNCTION-METHOD-CLASS| pcl::|SETF PCL GENERIC-FUNCTION-METHOD-COMBINATION| pcl::set-methods pcl::method-p pcl::method-generic-function pcl::intern-function-name pcl::method-qualifiers pcl::unparse-specializers pcl::compute-discriminating-function-arglist-info pcl::get-method walker::variable-lexical-p walker::recons walker::relist* pcl::expand-symbol-macrolet-internal pcl::specializerp pcl::specializer-type pcl::specializer-from-type pcl::printing-random-thing-internal pcl::make-keyword pcl::|SETF PCL METHOD-FUNCTION-GET| pcl::can-optimize-access pcl::optimize-slot-value pcl::optimize-set-slot-value pcl::optimize-slot-boundp pcl::generic-function-name-p pcl::optimize-generic-function-call (system::%init . #((system::setvv 457 (system::mc lisp::nil 121)) (system::setvv 455 (system::mc lisp::nil 120)) (system::setvv 424 (system::mc lisp::nil 119)) (system::setvv 367 (system::mc lisp::nil 118)) (lisp::proclaim (lisp::quote (lisp::notinline pcl::make-a-method pcl::add-named-method pcl::ensure-generic-function-using-class pcl::add-method pcl::remove-method))) (system::*make-special (lisp::quote pcl::*early-functions*)) (lisp::or (lisp::boundp (lisp::quote pcl::*early-functions*)) (lisp::setq pcl::*early-functions* (lisp::quote ((pcl::make-a-method pcl::early-make-a-method pcl::real-make-a-method) (pcl::add-named-method pcl::early-add-named-method pcl::real-add-named-method))))) (system::mfsfun (lisp::quote pcl::redirect-early-function-internal) 0 2) (lisp::block lisp::nil (lisp::let* ((#0=#:g3899 pcl::*early-functions*) (pcl::fns (lisp::car #0#))) (lisp::tagbody #1=#:g3900 (lisp::if (lisp::endp #0#) (lisp::return (lisp::progn lisp::nil))) (lisp::tagbody (lisp::let ((pcl::name (lisp::car pcl::fns)) (pcl::early-name (lisp::cadr pcl::fns))) (pcl::redirect-early-function-internal pcl::name pcl::early-name))) (lisp::setq #0# (lisp::cdr #0#) pcl::fns (lisp::car #0#)) (lisp::go #1#)))) (system::*make-special (lisp::quote pcl::*generic-function-fixups*)) (lisp::or (lisp::boundp (lisp::quote pcl::*generic-function-fixups*)) (lisp::setq pcl::*generic-function-fixups* (lisp::quote ((pcl::add-method ((lisp::generic-function lisp::method) (lisp::standard-generic-function lisp::method) pcl::real-add-method)) (pcl::remove-method ((lisp::generic-function lisp::method) (lisp::standard-generic-function lisp::method) pcl::real-remove-method)) (pcl::get-method ((lisp::generic-function pcl::qualifiers pcl::specializers lisp::&optional (pcl::errorp lisp::t)) (lisp::standard-generic-function lisp::t lisp::t) pcl::real-get-method)) (pcl::ensure-generic-function-using-class ((lisp::generic-function pcl::function-specifier lisp::&key pcl::generic-function-class pcl::environment lisp::&allow-other-keys) (lisp::generic-function lisp::t) pcl::real-ensure-gf-using-class--generic-function) ((lisp::generic-function pcl::function-specifier lisp::&key pcl::generic-function-class pcl::environment lisp::&allow-other-keys) (lisp::null lisp::t) pcl::real-ensure-gf-using-class--null)) (pcl::make-method-lambda ((pcl::proto-generic-function pcl::proto-method pcl::lambda-expression pcl::environment) (lisp::standard-generic-function lisp::standard-method lisp::t lisp::t) pcl::real-make-method-lambda)) (pcl::make-method-initargs-form ((pcl::proto-generic-function pcl::proto-method pcl::lambda-expression pcl::lambda-list pcl::environment) (lisp::standard-generic-function lisp::standard-method lisp::t lisp::t lisp::t) pcl::real-make-method-initargs-form)) (pcl::compute-effective-method ((lisp::generic-function pcl::combin pcl::applicable-methods) (lisp::generic-function pcl::standard-method-combination lisp::t) pcl::standard-compute-effective-method)))))) (system::putprop (lisp::quote pcl::defgeneric) (lisp::quote 2) #2=(lisp::quote system::pretty-print-format)) (system::mm (lisp::quote pcl::defgeneric) 1) (system::mfsfun (lisp::quote pcl::expand-defgeneric) 2 3) (system::mf (lisp::quote pcl::load-defgeneric) 3) (system::mm (lisp::quote pcl::defmethod) 4) (system::mf (lisp::quote pcl::prototypes-for-make-method-lambda) 5) (system::mf (lisp::quote pcl::method-prototype-for-gf) 6) (system::*make-special (lisp::quote pcl::*optimize-asv-funcall-p*)) (lisp::or (lisp::boundp (lisp::quote pcl::*optimize-asv-funcall-p*)) (lisp::setq pcl::*optimize-asv-funcall-p* lisp::nil)) (system::*make-special (lisp::quote pcl::*asv-readers*)) (system::*make-special (lisp::quote pcl::*asv-writers*)) (system::*make-special (lisp::quote pcl::*asv-boundps*)) (system::mfsfun (lisp::quote pcl::expand-defmethod) 7 7) (system::mfsfun (lisp::quote pcl::interned-symbol-p) 8 1) (system::mfvfun (lisp::quote pcl::make-defmethod-form) 9 1798) (system::mfvfun (lisp::quote pcl::make-defmethod-form-internal) 10 1798) (system::mm (lisp::quote pcl::make-method-function) 11) (system::mf (lisp::quote pcl::make-method-function-internal) 12) (system::mf (lisp::quote pcl::add-method-declarations) 13) (system::mfsfun (lisp::quote pcl::real-make-method-initargs-form) 14 5) (lisp::if (lisp::not (lisp::fboundp (lisp::quote pcl::make-method-initargs-form))) (lisp::progn (lisp::setf (pcl::gdefinition (lisp::quote pcl::make-method-initargs-form)) (lisp::symbol-function (lisp::quote pcl::real-make-method-initargs-form))))) (system::mf (lisp::quote pcl::real-make-method-lambda) 15) (system::mf (lisp::quote pcl::make-method-lambda-internal) 16) (lisp::if (lisp::not (lisp::fboundp (lisp::quote pcl::make-method-lambda))) (lisp::progn (lisp::setf (pcl::gdefinition (lisp::quote pcl::make-method-lambda)) (lisp::symbol-function (lisp::quote pcl::real-make-method-lambda))))) (system::putprop (lisp::quote pcl::simple-lexical-method-functions) (lisp::quote 1) #2#) (system::mm (lisp::quote pcl::simple-lexical-method-functions) 17) (system::putprop (lisp::quote pcl::fast-lexical-method-functions) (lisp::quote 1) #2#) (system::mm (lisp::quote pcl::fast-lexical-method-functions) 18) (system::putprop (lisp::quote pcl::bind-simple-lexical-method-macros) (lisp::quote 1) #2#) (system::mm (lisp::quote pcl::bind-simple-lexical-method-macros) 19) (system::define-structure (lisp::quote pcl::method-call) (lisp::quote pcl::method-call-) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote ((lisp::function (lisp::function lisp::identity) lisp::t lisp::nil 0) (pcl::call-method-args lisp::nil lisp::t lisp::nil 1))) (lisp::quote pcl::copy-method-call) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote (pcl::make-method-call)) (lisp::quote 2) (lisp::quote pcl::method-call-p) (lisp::quote lisp::nil)) (system::mfvfun-key (lisp::quote pcl::make-method-call) 20 16384 21) (system::mm (lisp::quote pcl::invoke-method-call1) 22) (system::mm (lisp::quote pcl::invoke-method-call) 23) (system::define-structure (lisp::quote pcl::fast-method-call) (lisp::quote pcl::fast-method-call-) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote ((lisp::function (lisp::function lisp::identity) lisp::t lisp::nil 0) (pcl::pv-cell lisp::nil lisp::t lisp::nil 1) (pcl::next-method-call lisp::nil lisp::t lisp::nil 2) (pcl::arg-info lisp::nil lisp::t lisp::nil 3))) (lisp::quote pcl::copy-fast-method-call) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote (pcl::make-fast-method-call)) (lisp::quote 4) (lisp::quote pcl::fast-method-call-p) (lisp::quote lisp::nil)) (system::mfvfun-key (lisp::quote pcl::make-fast-method-call) 24 16384 25) (system::mm (lisp::quote pcl::invoke-fast-method-call) 26) (system::define-structure (lisp::quote pcl::fast-instance-boundp) (lisp::quote pcl::fast-instance-boundp-) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote ((pcl::index 0 lisp::fixnum lisp::nil 0))) (lisp::quote pcl::copy-fast-instance-boundp) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote (pcl::make-fast-instance-boundp)) (lisp::quote 1) (lisp::quote pcl::fast-instance-boundp-p) (lisp::quote lisp::nil)) (system::mfvfun-key (lisp::quote pcl::make-fast-instance-boundp) 27 16384 28) (system::*make-special (lisp::quote pcl::*allow-emf-call-tracing-p*)) (lisp::or (lisp::boundp (lisp::quote pcl::*allow-emf-call-tracing-p*)) (lisp::setq pcl::*allow-emf-call-tracing-p* lisp::nil)) (system::*make-special (lisp::quote pcl::*enable-emf-call-tracing-p*)) (lisp::or (lisp::boundp (lisp::quote pcl::*enable-emf-call-tracing-p*)) (lisp::setq pcl::*enable-emf-call-tracing-p* lisp::nil)) (system::*make-special (lisp::quote pcl::*emf-call-trace-size*)) (lisp::or (lisp::boundp (lisp::quote pcl::*emf-call-trace-size*)) (lisp::setq pcl::*emf-call-trace-size* 200)) (system::*make-special (lisp::quote pcl::*emf-call-trace*)) (lisp::or (lisp::boundp (lisp::quote pcl::*emf-call-trace*)) (lisp::setq pcl::*emf-call-trace* lisp::nil)) (system::*make-special (lisp::quote pcl::emf-call-trace-index)) (lisp::or (lisp::boundp (lisp::quote pcl::emf-call-trace-index)) (lisp::setq pcl::emf-call-trace-index 0)) (system::mfsfun (lisp::quote pcl::show-emf-call-trace) 29 0) (system::mfsfun (lisp::quote pcl::trace-emf-call-internal) 30 3) (system::mm (lisp::quote pcl::trace-emf-call) 31) (system::mm (lisp::quote pcl::invoke-effective-method-function-fast) 32) (system::mm (lisp::quote pcl::invoke-effective-method-function) 33) (system::setvv 145 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::setvv 149 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::setvv 152 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mf (lisp::quote pcl::invoke-emf) 34) (system::mfsfun (lisp::quote pcl::gf-make-function-from-emf) 35 2) (system::putprop (lisp::quote pcl::bind-fast-lexical-method-macros) (lisp::quote 1) #2#) (system::mm (lisp::quote pcl::bind-fast-lexical-method-macros) 36) (system::putprop (lisp::quote pcl::bind-lexical-method-functions) (lisp::quote 1) #2#) (system::mm (lisp::quote pcl::bind-lexical-method-functions) 37) (system::setvv 183 lisp::lambda-list-keywords) (system::putprop (lisp::quote pcl::bind-args) (lisp::quote 1) #2#) (system::mm (lisp::quote pcl::bind-args) 38) (system::mfsfun (lisp::quote pcl::get-key-arg) 39 2) (system::mfsfun (lisp::quote pcl::get-key-arg1) 40 2) (system::mf (lisp::quote pcl::walk-method-lambda) 41) (system::mf (lisp::quote pcl::generic-function-name-p) 42) (system::mfsfun (lisp::quote pcl::make-parameter-references) 43 5) (system::*make-special (lisp::quote pcl::*method-function-plist*)) (lisp::or (lisp::boundp (lisp::quote pcl::*method-function-plist*)) (lisp::setq pcl::*method-function-plist* (lisp::make-hash-table :test (lisp::function lisp::eq)))) (system::*make-special (lisp::quote pcl::*mf1*)) (lisp::or (lisp::boundp (lisp::quote pcl::*mf1*)) (lisp::setq pcl::*mf1* lisp::nil)) (system::*make-special (lisp::quote pcl::*mf1p*)) (lisp::or (lisp::boundp (lisp::quote pcl::*mf1p*)) (lisp::setq pcl::*mf1p* lisp::nil)) (system::*make-special (lisp::quote pcl::*mf1cp*)) (lisp::or (lisp::boundp (lisp::quote pcl::*mf1cp*)) (lisp::setq pcl::*mf1cp* lisp::nil)) (system::*make-special (lisp::quote pcl::*mf2*)) (lisp::or (lisp::boundp (lisp::quote pcl::*mf2*)) (lisp::setq pcl::*mf2* lisp::nil)) (system::*make-special (lisp::quote pcl::*mf2p*)) (lisp::or (lisp::boundp (lisp::quote pcl::*mf2p*)) (lisp::setq pcl::*mf2p* lisp::nil)) (system::*make-special (lisp::quote pcl::*mf2cp*)) (lisp::or (lisp::boundp (lisp::quote pcl::*mf2cp*)) (lisp::setq pcl::*mf2cp* lisp::nil)) (system::mfsfun (lisp::quote pcl::method-function-plist) 44 1) (system::mfsfun (lisp::quote pcl::|SETF PCL METHOD-FUNCTION-PLIST|) 45 2) (system::mfvfun (lisp::quote pcl::method-function-get) 46 770) (system::mfsfun (lisp::quote pcl::|SETF PCL METHOD-FUNCTION-GET|) 47 3) (system::mfsfun (lisp::quote pcl::method-function-pv-table) 48 1) (system::mfsfun (lisp::quote pcl::method-function-method) 49 1) (system::mfsfun (lisp::quote pcl::method-function-needs-next-methods-p) 50 1) (system::mm (lisp::quote pcl::method-function-closure-generator) 51) (system::mfvfun (lisp::quote pcl::load-defmethod) 52 1798) (system::mfsfun (lisp::quote pcl::load-defmethod-internal) 53 7) (system::mfsfun (lisp::quote pcl::make-method-spec) 54 3) (system::mfvfun (lisp::quote pcl::initialize-method-function) 55 769) (system::mf (lisp::quote pcl::analyze-lambda-list) 56) (system::mfsfun (lisp::quote pcl::keyword-spec-name) 57 1) (system::mfsfun (lisp::quote pcl::ftype-declaration-from-lambda-list) 58 1) (system::mfsfun (lisp::quote pcl::proclaim-defgeneric) 59 2) (system::*make-special (lisp::quote pcl::*early-generic-functions*)) (lisp::or (lisp::boundp (lisp::quote pcl::*early-generic-functions*)) (lisp::setq pcl::*early-generic-functions* lisp::nil)) (system::mf (lisp::quote pcl::ensure-generic-function) 60) (system::mfsfun (lisp::quote pcl::generic-clobbers-function) 61 1) (system::*make-special (lisp::quote pcl::*sgf-wrapper*)) (lisp::or (lisp::boundp (lisp::quote pcl::*sgf-wrapper*)) (lisp::setq pcl::*sgf-wrapper* (pcl::make-wrapper (pcl::early-class-size (lisp::quote lisp::standard-generic-function))))) (system::*make-special (lisp::quote pcl::*sgf-slots-init*)) (lisp::or (lisp::boundp (lisp::quote pcl::*sgf-slots-init*)) (lisp::setq pcl::*sgf-slots-init* (lisp::map (lisp::quote lisp::vector) (lisp::function (lisp::lambda (pcl::canonical-slot) (lisp::if (pcl::memq (lisp::getf pcl::canonical-slot :name) (lisp::quote (pcl::arg-info pcl::source))) pcl::*slot-unbound* (lisp::let ((pcl::initfunction (lisp::getf pcl::canonical-slot :initfunction))) (lisp::if pcl::initfunction (lisp::funcall pcl::initfunction) pcl::*slot-unbound*))))) (pcl::early-collect-inheritance (lisp::quote lisp::standard-generic-function))))) (system::*make-special (lisp::quote pcl::*sgf-method-class-index*)) (lisp::or (lisp::boundp (lisp::quote pcl::*sgf-method-class-index*)) (lisp::setq pcl::*sgf-method-class-index* (pcl::bootstrap-slot-index (lisp::quote lisp::standard-generic-function) (lisp::quote pcl::method-class)))) (system::setvv 231 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfsfun (lisp::quote pcl::early-gf-p) 62 1) (system::*make-special (lisp::quote pcl::*sgf-methods-index*)) (lisp::or (lisp::boundp (lisp::quote pcl::*sgf-methods-index*)) (lisp::setq pcl::*sgf-methods-index* (pcl::bootstrap-slot-index (lisp::quote lisp::standard-generic-function) (lisp::quote pcl::methods)))) (system::mm (lisp::quote pcl::early-gf-methods) 63) (system::*make-special (lisp::quote pcl::*sgf-arg-info-index*)) (lisp::or (lisp::boundp (lisp::quote pcl::*sgf-arg-info-index*)) (lisp::setq pcl::*sgf-arg-info-index* (pcl::bootstrap-slot-index (lisp::quote lisp::standard-generic-function) (lisp::quote pcl::arg-info)))) (system::mm (lisp::quote pcl::early-gf-arg-info) 64) (system::*make-special (lisp::quote pcl::*sgf-dfun-state-index*)) (lisp::or (lisp::boundp (lisp::quote pcl::*sgf-dfun-state-index*)) (lisp::setq pcl::*sgf-dfun-state-index* (pcl::bootstrap-slot-index (lisp::quote lisp::standard-generic-function) (lisp::quote pcl::dfun-state)))) (system::define-structure (lisp::quote pcl::arg-info) (lisp::quote pcl::||) (lisp::quote lisp::t) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote ((pcl::arg-info-lambda-list :no-lambda-list lisp::t lisp::nil 0) (pcl::arg-info-precedence lisp::nil lisp::t lisp::nil 1) (pcl::arg-info-metatypes lisp::nil lisp::t lisp::nil 2) (pcl::arg-info-number-optional lisp::nil lisp::t lisp::nil 3) (pcl::arg-info-key/rest-p lisp::nil lisp::t lisp::nil 4) (pcl::arg-info-keywords lisp::nil lisp::t lisp::nil 5) (pcl::gf-info-simple-accessor-type lisp::nil lisp::t lisp::nil 6) (pcl::gf-precompute-dfun-and-emf-p lisp::nil lisp::t lisp::nil 7) (pcl::gf-info-static-c-a-m-emf lisp::nil lisp::t lisp::nil 8) (pcl::gf-info-c-a-m-emf-std-p lisp::t lisp::t lisp::nil 9) (pcl::gf-info-fast-mf-p lisp::nil lisp::t lisp::nil 10))) (lisp::quote pcl::copy-arg-info) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote lisp::nil) (lisp::quote (pcl::|__si::MAKE-ARG-INFO| (pcl::make-arg-info lisp::nil))) (lisp::quote 11) (lisp::quote pcl::arg-info-p) (lisp::quote lisp::nil)) (system::mfvfun-key (lisp::quote pcl::|__si::MAKE-ARG-INFO|) 65 16384 66) (system::mfsfun (lisp::quote pcl::make-arg-info) 67 0) (system::mfsfun (lisp::quote pcl::arg-info-valid-p) 68 1) (system::mfsfun (lisp::quote pcl::arg-info-applyp) 69 1) (system::mfsfun (lisp::quote pcl::arg-info-number-required) 70 257) (system::mfsfun (lisp::quote pcl::arg-info-nkeys) 71 1) (system::mm (lisp::quote pcl::esetf) 72) (system::setvv 242 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::setvv 243 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfvfun-key (lisp::quote pcl::set-arg-info) 73 16385 74) (system::mf (lisp::quote pcl::check-method-arg-info) 75) (system::mfsfun (lisp::quote pcl::set-arg-info1) 76 6) (system::mfvfun-key (lisp::quote pcl::ensure-generic-function-using-class) 77 16386 78) (system::setvv 276 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfvfun (lisp::quote pcl::make-early-gf) 79 1025) (system::setvv 278 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfvfun (lisp::quote pcl::set-dfun) 80 1025) (system::setvv 280 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfsfun (lisp::quote pcl::gf-dfun-cache) 81 1) (system::setvv 281 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfsfun (lisp::quote pcl::gf-dfun-info) 82 1) (system::*make-special (lisp::quote pcl::*sgf-name-index*)) (lisp::or (lisp::boundp (lisp::quote pcl::*sgf-name-index*)) (lisp::setq pcl::*sgf-name-index* (pcl::bootstrap-slot-index (lisp::quote lisp::standard-generic-function) (lisp::quote pcl::name)))) (system::setvv 282 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfsfun (lisp::quote pcl::early-gf-name) 83 1) (system::setvv 284 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::setvv 285 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfsfun (lisp::quote pcl::gf-lambda-list) 84 1) (system::mm (lisp::quote pcl::real-ensure-gf-internal) 85) (system::mfvfun-key (lisp::quote pcl::real-ensure-gf-using-class--generic-function) 86 16386 87) (system::mfvfun-key (lisp::quote pcl::real-ensure-gf-using-class--null) 88 16386 89) (system::setvv 304 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mf (lisp::quote pcl::get-generic-function-info) 90) (system::mfvfun (lisp::quote pcl::early-make-a-method) 91 1798) (system::mf (lisp::quote pcl::real-make-a-method) 92) (system::mf (lisp::quote pcl::early-method-function) 93) (system::mfsfun (lisp::quote pcl::early-method-class) 94 1) (system::mfsfun (lisp::quote pcl::early-method-standard-accessor-p) 95 1) (system::mf (lisp::quote pcl::early-method-standard-accessor-slot-name) 96) (system::mfvfun (lisp::quote pcl::early-method-specializers) 97 513) (system::mfsfun (lisp::quote pcl::early-method-qualifiers) 98 1) (system::mfsfun (lisp::quote pcl::early-method-lambda-list) 99 1) (system::setvv 314 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfvfun (lisp::quote pcl::early-add-named-method) 100 16388) (system::setvv 317 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfsfun (lisp::quote pcl::add-method) 101 2) (system::setvv 321 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::setvv 322 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfsfun (lisp::quote pcl::remove-method) 102 2) (system::setvv 323 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfvfun (lisp::quote pcl::get-method) 103 1027) (system::*make-special (lisp::quote pcl::*fegf-debug-p*)) (lisp::or (lisp::boundp (lisp::quote pcl::*fegf-debug-p*)) (lisp::setq pcl::*fegf-debug-p* lisp::nil)) (system::setvv 327 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::setvv 330 (compiler::name-to-sd (lisp::quote pcl::std-instance))) (system::mfvfun (lisp::quote pcl::fix-early-generic-functions) 104 256) (system::mf (lisp::quote pcl::parse-defmethod) 105) (system::mfsfun (lisp::quote pcl::parse-specializers) 106 1) (system::mfsfun (lisp::quote pcl::unparse-specializers) 107 1) (system::mf (lisp::quote pcl::parse-method-or-spec) 108) (system::mfsfun (lisp::quote pcl::extract-parameters) 109 1) (system::mfsfun (lisp::quote pcl::extract-lambda-list) 110 1) (system::mfsfun (lisp::quote pcl::extract-specializer-names) 111 1) (system::mfsfun (lisp::quote pcl::extract-required-parameters) 112 1) (system::mf (lisp::quote pcl::parse-specialized-lambda-list) 113) (lisp::setq pcl::*boot-state* (lisp::quote pcl::early)) (system::putprop (lisp::quote pcl::symbol-macrolet) (lisp::quote 1) #2#) (system::mm (lisp::quote pcl::symbol-macrolet) 114) (system::mfsfun (lisp::quote pcl::expand-symbol-macrolet-internal) 115 4) (system::putprop (lisp::quote pcl::with-slots) (lisp::quote 2) #2#) (system::mm (lisp::quote pcl::with-slots) 116) (system::putprop (lisp::quote pcl::with-accessors) (lisp::quote 2) #2#) (system::mm (lisp::quote pcl::with-accessors) 117) (system::debug (lisp::quote pcl::redirect-early-function-internal) (lisp::quote (pcl::early))) (system::debug (lisp::quote pcl::expand-defgeneric) (lisp::quote (pcl::option #:g3912))) (system::debug (lisp::quote pcl::load-defgeneric) (lisp::quote (pcl::function-specifier pcl::lambda-list pcl::initargs))) (system::debug (lisp::quote pcl::prototypes-for-make-method-lambda) (lisp::quote (pcl::name))) (system::debug (lisp::quote pcl::method-prototype-for-gf) (lisp::quote (pcl::name))) (system::debug (lisp::quote pcl::expand-defmethod) (lisp::quote (pcl::*make-instance-function-keys* lisp::nil pcl::*asv-readers* pcl::*asv-writers* pcl::*asv-boundps*))) (system::debug (lisp::quote pcl::make-defmethod-form) (lisp::quote (pcl::name pcl::qualifiers pcl::specializers pcl::unspecialized-lambda-list pcl::method-class-name pcl::initargs-form pcl::pv-table-symbol))) (system::debug (lisp::quote pcl::make-defmethod-form-internal) (lisp::quote (pcl::name pcl::qualifiers pcl::specializers-form pcl::unspecialized-lambda-list pcl::method-class-name pcl::initargs-form pcl::pv-table-symbol))) (system::debug (lisp::quote pcl::make-method-function-internal) (lisp::quote (pcl::method-lambda pcl::env))) (system::debug (lisp::quote pcl::add-method-declarations) (lisp::quote (pcl::name pcl::qualifiers pcl::lambda-list pcl::body pcl::env))) (system::debug (lisp::quote pcl::real-make-method-lambda) (lisp::quote (lisp::nil lisp::nil pcl::method-lambda pcl::env))) (system::debug (lisp::quote pcl::make-method-lambda-internal) (lisp::quote (pcl::method-lambda pcl::env pcl::name-decl pcl::sll-decl pcl::method-name pcl::generic-function-name pcl::specialized-lambda-list pcl::required-parameters pcl::slots pcl::calls pcl::parameters-to-reference pcl::class-declarations pcl::method-lambda pcl::constant-value-p pcl::constant-value pcl::plist pcl::applyp pcl::p))) (system::debug (lisp::quote pcl::make-method-call) (lisp::quote (lisp::function pcl::call-method-args))) (system::debug (lisp::quote pcl::make-fast-method-call) (lisp::quote (lisp::function pcl::pv-cell pcl::next-method-call pcl::arg-info))) (system::debug (lisp::quote pcl::make-fast-instance-boundp) (lisp::quote (pcl::index))) (system::debug (lisp::quote pcl::invoke-emf) (lisp::quote (pcl::emf pcl::args pcl::arg-info pcl::restp pcl::nreq pcl::rest-args pcl::req-args))) (system::debug (lisp::quote pcl::gf-make-function-from-emf) (lisp::quote (pcl::emf pcl::arg-info pcl::nreq pcl::restp))) (system::debug (lisp::quote pcl::walk-method-lambda) (lisp::quote (pcl::method-lambda pcl::required-parameters pcl::env pcl::slots pcl::calls pcl::call-next-method-p pcl::closurep pcl::next-method-p-p))) (system::debug (lisp::quote pcl::generic-function-name-p) (lisp::quote (pcl::name))) (system::debug (lisp::quote pcl::make-parameter-references) (lisp::quote (pcl::declarations))) (system::debug (lisp::quote pcl::method-function-get) (lisp::quote (pcl::method-function pcl::key pcl::default))) (system::debug (lisp::quote pcl::load-defmethod) (lisp::quote (lisp::class pcl::name pcl::quals pcl::specls pcl::ll pcl::initargs pcl::pv-table-symbol))) (system::debug (lisp::quote pcl::initialize-method-function) (lisp::quote (pcl::initargs pcl::method-spec pcl::plist pcl::pv-table-symbol pcl::mff))) (system::debug (lisp::quote pcl::analyze-lambda-list) (lisp::quote (pcl::lambda-list pcl::x #:g4093))) (system::debug (lisp::quote pcl::ftype-declaration-from-lambda-list) (lisp::quote (pcl::keywords))) (system::debug (lisp::quote pcl::ensure-generic-function) (lisp::quote (pcl::function-specifier pcl::all-keys))) (system::debug (lisp::quote pcl::|__si::MAKE-ARG-INFO|) (lisp::quote (pcl::arg-info-lambda-list pcl::arg-info-precedence pcl::arg-info-metatypes pcl::arg-info-number-optional pcl::arg-info-key/rest-p pcl::arg-info-keywords pcl::gf-info-simple-accessor-type pcl::gf-precompute-dfun-and-emf-p pcl::gf-info-static-c-a-m-emf pcl::gf-info-c-a-m-emf-std-p pcl::gf-info-fast-mf-p))) (system::debug (lisp::quote pcl::set-arg-info) (lisp::quote (pcl::gf pcl::new-method pcl::lambda-list pcl::first-p lisp::nil pcl::lambda-list-p))) (system::debug (lisp::quote pcl::check-method-arg-info) (lisp::quote (pcl::gf pcl::arg-info lisp::method pcl::keywords))) (system::debug (lisp::quote pcl::set-arg-info1) (lisp::quote (pcl::existing-p pcl::nreq pcl::metatypes lisp::type #:g4107 lisp::method pcl::specializers lisp::class pcl::new-type))) (system::debug (lisp::quote pcl::ensure-generic-function-using-class) (lisp::quote (pcl::existing pcl::spec lisp::nil pcl::lambda-list pcl::lambda-list-p))) (system::debug (lisp::quote pcl::make-early-gf) (lisp::quote (pcl::fin pcl::lambda-list pcl::lambda-list-p lisp::function))) (system::debug (lisp::quote pcl::set-dfun) (lisp::quote (pcl::gf pcl::dfun pcl::cache pcl::info))) (system::debug (lisp::quote pcl::gf-lambda-list) (lisp::quote (lisp::method pcl::ll pcl::k))) (system::debug (lisp::quote pcl::real-ensure-gf-using-class--generic-function) (lisp::quote (#:g4132 pcl::function-specifier pcl::all-keys pcl::environment pcl::lambda-list pcl::generic-function-class lisp::nil pcl::lambda-list-p pcl::gf-class-p))) (system::debug (lisp::quote pcl::real-ensure-gf-using-class--null) (lisp::quote (#:g4141 pcl::function-specifier pcl::all-keys pcl::environment pcl::lambda-list pcl::generic-function-class lisp::nil pcl::lambda-list-p))) (system::debug (lisp::quote pcl::get-generic-function-info) (lisp::quote (pcl::gf pcl::arg-info pcl::metatypes))) (system::debug (lisp::quote pcl::early-make-a-method) (lisp::quote (lisp::class pcl::qualifiers pcl::arglist pcl::specializers pcl::initargs pcl::doc pcl::slot-name))) (system::debug (lisp::quote pcl::real-make-a-method) (lisp::quote (lisp::class pcl::qualifiers pcl::lambda-list pcl::specializers pcl::initargs pcl::doc pcl::slot-name))) (system::debug (lisp::quote pcl::early-method-function) (lisp::quote (pcl::early-method))) (system::debug (lisp::quote pcl::early-method-standard-accessor-slot-name) (lisp::quote (pcl::early-method))) (system::debug (lisp::quote pcl::early-method-specializers) (lisp::quote (pcl::early-method pcl::objectsp))) (system::debug (lisp::quote pcl::early-add-named-method) (lisp::quote (pcl::generic-function-name pcl::qualifiers pcl::specializers #:g4150 pcl::m))) (system::debug (lisp::quote pcl::add-method) (lisp::quote (#:g4154 #:g4156))) (system::debug (lisp::quote pcl::get-method) (lisp::quote (lisp::generic-function pcl::m pcl::specializers pcl::errorp))) (system::debug (lisp::quote pcl::fix-early-generic-functions) (lisp::quote (pcl::early-gf-spec pcl::spec pcl::methods pcl::methods #:g4177 pcl::lambda-list pcl::specializers pcl::method-fn-name pcl::fn-name pcl::fn pcl::initargs))) (system::debug (lisp::quote pcl::parse-defmethod) (lisp::quote (pcl::cdr-of-form #:g4193))) (system::debug (lisp::quote pcl::parse-method-or-spec) (lisp::quote (pcl::spec pcl::errorp))) (system::debug (lisp::quote pcl::parse-specialized-lambda-list) (lisp::quote (pcl::arglist pcl::post-keyword))) (system::debug (lisp::quote pcl::expand-symbol-macrolet-internal) (lisp::quote (pcl::env pcl::specs pcl::entry pcl::kind pcl::gensyms))))))
)
